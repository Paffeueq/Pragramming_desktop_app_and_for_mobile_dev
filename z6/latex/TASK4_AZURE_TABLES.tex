\section{Zadanie 4 – Praca z danymi (Zapis i odczyt w bazie danych)}

\subsection{Cel}
Celem zadania było stworzenie systemu CRUD (Create, Read, Update, Delete) dla produktów przy użyciu \textbf{Azure Tables} – zarządzanej usługi NoSQL w chmurze Microsoft Azure. System udostępnia RESTful API do zarządzania produktami z trwałym przechowywaniem danych w usłudze Azure.

\begin{itemize}
	\item \textbf{Azure Storage Account:} \texttt{z6storage} (West Europe)
	\item \textbf{Azure Tables:} Zarządzana NoSQL na bazie Cosmos DB API
	\item \textbf{Persistent Data:} Dane zachowywane między wywołaniami funkcji
	\item \textbf{Automatic Replication:} Replikacja danych dla wysokiej dostępności
\end{itemize}

\subsection{Konfiguracja Azure Tables}

\subsubsection{Inicjalizacja bazy danych}

Tabela \texttt{products} jest tworzona automatycznie przy starcie aplikacji:

\begin{lstlisting}[language=Python,caption=Inicjalizacja Azure Tables]
import os
import uuid
import json
import logging
from datetime import datetime
from azure.data.tables import TableServiceClient
import azure.functions as func

STORAGE_CONNECTION_STRING = os.getenv("AzureWebJobsStorage", "")
PRODUCTS_TABLE_NAME = "products"

def get_table_client():
    """Pobierz klienta Azure Tables dla tabeli produktów."""
    try:
        table_service_client = TableServiceClient.from_connection_string(
            STORAGE_CONNECTION_STRING
        )
        table_client = table_service_client.get_table_client(
            table_name=PRODUCTS_TABLE_NAME
        )
        logging.info(f'Connected to Azure Table: {PRODUCTS_TABLE_NAME}')
        return table_client
    except Exception as e:
        logging.error(f'Error connecting to Azure Table: {str(e)}')
        raise

def init_database():
    """Utwórz tabelę jeśli nie istnieje."""
    try:
        table_service_client = TableServiceClient.from_connection_string(
            STORAGE_CONNECTION_STRING
        )
        table_service_client.create_table_if_not_exists(
            table_name=PRODUCTS_TABLE_NAME
        )
        logging.info('[DATABASE] Initialized Azure Table: products')
    except Exception as e:
        logging.error(f'[DATABASE] Error initializing: {str(e)}')

# Uruchom przy starcie
init_database()
\end{lstlisting}

\subsubsection{Schemat tabeli}

Każdy rekord w Azure Tables posiada następujące pola:

\begin{center}
\begin{tabular}{|l|l|l|l|}
\hline
\textbf{Pole} & \textbf{Typ} & \textbf{Rola} & \textbf{Opis} \\
\hline
PartitionKey & STRING & Klucz partycji & Zawsze: "product" \\
RowKey & STRING & Klucz wiersza & UUID produktu \\
name & STRING & Dane & Nazwa produktu \\
description & STRING & Dane & Opis produktu \\
price & DOUBLE & Dane & Cena w USD \\
quantity & INT32 & Dane & Liczba dostępnych sztuk \\
created\_at & STRING & Metadane & ISO timestamp \\
updated\_at & STRING & Metadane & ISO timestamp \\
\hline
\end{tabular}
\end{center}

\subsection{Endpoint: SaveProduct – Zapis produktu}

\textbf{Metoda:} POST \\
\textbf{URL:} \texttt{/api/SaveProduct} \\
\textbf{Status:} 201 Created

\subsubsection{Request i Response}

\begin{lstlisting}[language=json,caption=Przykładowy request SaveProduct]
POST /api/SaveProduct
Content-Type: application/json

{
  "name": "Laptop Dell",
  "description": "High-performance laptop",
  "price": 1200,
  "quantity": 5
}
\end{lstlisting}

\begin{lstlisting}[language=json,caption=Przykładowy response SaveProduct]
{
  "success": true,
  "message": "Product saved successfully",
  "product_id": "8f9e1b2c-3a4d-5e6f-7890-a1b2c3d4e5f6",
  "name": "Laptop Dell",
  "price": 1200,
  "quantity": 5,
  "created_at": "2025-12-07T15:30:22.450123"
}
\end{lstlisting}

\subsubsection{Implementacja funkcji}

\begin{lstlisting}[language=Python,caption=Funkcja SaveProduct]
@app.route(route="SaveProduct", methods=["POST"], auth_level=func.AuthLevel.ANONYMOUS)
def save_product(req: func.HttpRequest) -> func.HttpResponse:
    try:
        req_body = req.get_json()
        if 'name' not in req_body or 'price' not in req_body:
            return func.HttpResponse(json.dumps({"error": "Missing name or price"}), status_code=400)
        
        product_id = str(uuid.uuid4())
        now = datetime.utcnow().isoformat()
        product_entity = {
            "PartitionKey": "product",
            "RowKey": product_id,
            "name": req_body['name'],
            "description": req_body.get('description', ''),
            "price": float(req_body['price']),
            "quantity": int(req_body.get('quantity', 0)),
            "created_at": now,
            "updated_at": now
        }

        table_client = get_table_client()
        table_client.upsert_entity(entity=product_entity)
        logging.info(f'[DATABASE] Saved product: {product_id}')

        response = {"success": True, "message": "Product saved successfully",
                    "product_id": product_id, "name": req_body['name'],
                    "price": req_body['price'], "quantity": req_body.get('quantity', 0),
                    "created_at": now}
        return func.HttpResponse(json.dumps(response), status_code=201)
    except Exception as e:
        logging.error(f'[DATABASE] Error saving product: {str(e)}')
        return func.HttpResponse(json.dumps({"error": str(e)}), status_code=500)
\end{lstlisting}

\subsection{Endpoint: GetProducts – Pobranie wszystkich produktów}

\textbf{Metoda:} GET \\
\textbf{URL:} \texttt{/api/GetProducts} \\
\textbf{Status:} 200 OK

\subsubsection{Implementacja}

\begin{lstlisting}[language=Python,caption=Funkcja GetProducts]
@app.route(route="GetProducts", methods=["GET"], auth_level=func.AuthLevel.ANONYMOUS)
def get_products(req: func.HttpRequest) -> func.HttpResponse:
    try:
        table_client = get_table_client()
        entities = table_client.query_entities("PartitionKey eq 'product'")
        products = []
        for entity in entities:
            products.append({
                "id": entity["RowKey"],
                "name": entity["name"],
                "description": entity.get("description",""),
                "price": entity["price"],
                "quantity": entity["quantity"],
                "created_at": entity["created_at"],
                "updated_at": entity["updated_at"]
            })
        products.sort(key=lambda x: x['created_at'], reverse=True)
        response = {"success": True, "total": len(products), "products": products}
        return func.HttpResponse(json.dumps(response), status_code=200)
    except Exception as e:
        logging.error(f'[DATABASE] Error retrieving products: {str(e)}')
        return func.HttpResponse(json.dumps({"error": str(e)}), status_code=500)
\end{lstlisting}

\subsection{Endpoint: GetProduct – Pobranie produktu po ID}

\textbf{Metoda:} GET \\
\textbf{URL:} \texttt{/api/GetProduct?id=<product_id>} \\
\textbf{Status:} 200 OK / 404 Not Found

\begin{lstlisting}[language=Python,caption=Funkcja GetProduct]
@app.route(route="GetProduct", methods=["GET"], auth_level=func.AuthLevel.ANONYMOUS)
def get_product(req: func.HttpRequest) -> func.HttpResponse:
    try:
        product_id = req.params.get('id')
        if not product_id:
            return func.HttpResponse(json.dumps({"error": "Missing id parameter"}), status_code=400)
        table_client = get_table_client()
        try:
            entity = table_client.get_entity("product", product_id)
            product = {"id": entity["RowKey"], "name": entity["name"],
                       "description": entity.get("description",""),
                       "price": entity["price"], "quantity": entity["quantity"],
                       "created_at": entity["created_at"], "updated_at": entity["updated_at"]}
            return func.HttpResponse(json.dumps({"success": True, "product": product}), status_code=200)
        except Exception as e:
            if "ResourceNotFound" in str(e):
                return func.HttpResponse(json.dumps({"success": False, "error": "Product not found"}), status_code=404)
            raise
    except Exception as e:
        logging.error(f'[DATABASE] Error retrieving product: {str(e)}')
        return func.HttpResponse(json.dumps({"error": str(e)}), status_code=500)
\end{lstlisting}

\subsection{Endpoint: UpdateProduct – Aktualizacja produktu}

\begin{lstlisting}[language=Python,caption=Funkcja UpdateProduct]
@app.route(route="UpdateProduct", methods=["PUT"], auth_level=func.AuthLevel.ANONYMOUS)
def update_product(req: func.HttpRequest) -> func.HttpResponse:
    try:
        req_body = req.get_json()
        if 'id' not in req_body:
            return func.HttpResponse(json.dumps({"error": "Missing product id"}), status_code=400)
        product_id = req_body['id']
        table_client = get_table_client()
        try:
            entity = table_client.get_entity("product", product_id)
        except Exception as e:
            if "ResourceNotFound" in str(e):
                return func.HttpResponse(json.dumps({"success": False, "error": "Product not found"}), status_code=404)
            raise
        entity_dict = dict(entity)
        for field in ['name','description','price','quantity']:
            if field in req_body:
                entity_dict[field] = req_body[field]
        entity_dict['updated_at'] = datetime.utcnow().isoformat()
        table_client.upsert_entity(entity_dict)
        return func.HttpResponse(json.dumps({"success": True,"message":"Product updated","product_id":product_id,"updated_at":entity_dict['updated_at']}), status_code=200)
    except Exception as e:
        logging.error(f'[DATABASE] Error updating product: {str(e)}')
        return func.HttpResponse(json.dumps({"error": str(e)}), status_code=500)
\end{lstlisting}

\subsection{Endpoint: DeleteProduct – Usuwanie produktu}

\begin{lstlisting}[language=Python,caption=Funkcja DeleteProduct]
@app.route(route="DeleteProduct", methods=["DELETE"], auth_level=func.AuthLevel.ANONYMOUS)
def delete_product(req: func.HttpRequest) -> func.HttpResponse:
    try:
        product_id = req.params.get('id')
        if not product_id:
            return func.HttpResponse(json.dumps({"error":"Missing id parameter"}), status_code=400)
        table_client = get_table_client()
        try:
            table_client.delete_entity("product", product_id)
            return func.HttpResponse(json.dumps({"success":True,"message":"Product deleted","product_id":product_id}), status_code=200)
        except Exception as e:
            if "ResourceNotFound" in str(e):
                return func.HttpResponse(json.dumps({"success":False,"error":"Product not found"}), status_code=404)
            raise
    except Exception as e:
        logging.error(f'[DATABASE] Error deleting product: {str(e)}')
        return func.HttpResponse(json.dumps({"error": str(e)}), status_code=500)
\end{lstlisting}

\subsection{Testy i walidacja}

\begin{itemize}
\item \textbf{Test 1:} Zapis trzech produktów – status 201, ID generowane unikatowo.
\item \textbf{Test 2:} Pobranie wszystkich produktów – dane posortowane po \texttt{created\_at}, persystentne.
\item \textbf{Test 3:} Aktualizacja produktu – pola zmienione, timestamp \texttt{updated\_at} zaktualizowany.
\item \textbf{Test 4:} Usunięcie produktu – GET po ID zwraca 404.
\end{itemize}

\end{center}
