\chapter{Tworzenie aplikacji Blazor}

\section{Wstęp}
Blazor to framework do tworzenia aplikacji webowych w .NET.  Umożliwia tworzenie interaktywnych UI przy użyciu C# zamiast JavaScript. 

\section{Dlaczego Blazor?}

\subsection{Korzyści}
\begin{itemize}
	\item \textbf{Jeden zablon}: Obsługuje wiele trybów renderowania
	\item \textbf{SEO + szybkość}: SSR dla pierwszego ładowania
	\item \textbf{Wspólny kod}: Model, walidacja, logika w . NET (brak duplikacji JS/TS)
	\item \textbf{Progressive Enhancement}: Stopniowe dodawanie interaktywności
\end{itemize}

\section{Tryby renderowania}

\subsection{Static SSR (Server-Side Rendering)}
\begin{description}
	\item[Opis] Strona jest renderowana na serwerze, brak interaktywności
	\item[Użycie] Content, marketing, blog, landing page
	\item[Zalety] Minimalny rozmiar, SEO, szybkie ładowanie
	\item[Wady] Brak interaktywności
\end{description}

\begin{lstlisting}
	// Program.cs - nie dodajemy interactive
	var builder = WebApplication.CreateBuilder(args);
	builder.Services.AddRazorComponents();
	
	var app = builder.Build();
	app.MapRazorComponents<App>();
	app.Run();
\end{lstlisting}

\subsection{Interactive Server}
\begin{description}
	\item[Opis] Logika po stronie serwera, komunikacja przez WebSocket
	\item[Użycie] Backoffice, aplikacje z małą ilością użytkowników
	\item[Zalety] Mały transfer, szybkie TTFB, pełna moc serwera
	\item[Wady] Połączenia stałe, ograniczona skalowalność
\end{description}

\begin{lstlisting}
	// Component.razor
	@rendermode InteractiveServer
	
	@page "/counter"
	
	<h1>Counter</h1>
	<p>Current count: @count</p>
	<button @onclick="IncrementCount">Click me</button>
	
	@code {
		private int count = 0;
		
		private void IncrementCount()
		{
			count++;
		}
	}
\end{lstlisting}

\subsection{Interactive WebAssembly}
\begin{description}
	\item[Opis] Logika w przeglądarce, brak zależności od serwera
	\item[Użycie] Aplikacje wymagające offline, PWA
	\item[Zalety] Skalowalność, offline, PWA, brak roundtrip
	\item[Wady] Większy initial payload, cold start
\end{description}

\begin{lstlisting}
	// Program.cs - dodajemy WebAssembly
	builder.Services.AddRazorComponents()
	.AddInteractiveWebAssemblyComponents();
\end{lstlisting}

\subsection{Interactive Auto}
\begin{description}
	\item[Opis] Pierwszy raz Server (szybki), potem przełącza na WebAssembly
	\item[Użycie] Aplikacje wymagające szybkiego TTFB i skalowalności
	\item[Zalety] Najlepsze z obu światów
	\item[Wady] Większa złożoność
\end{description}

\begin{lstlisting}
	@rendermode InteractiveAuto
\end{lstlisting}

\section{Stream Rendering}

\subsection{Problem bez stream renderingu}
Użytkownik widzi białą stronę, aż wszystkie dane będą pobrane.

\subsection{Stream rendering - rozwiązanie}
\begin{enumerate}
	\item Szkielet strony zaraz
	\item Placeholder "Ładowanie..."
	\item Dane wypływają stopniowo
\end{enumerate}

\subsection{Implementacja}
\begin{lstlisting}
	@page "/products"
	@rendermode InteractiveServer
	
	<h1>Products</h1>
	
	@if (products == null)
	{
		<p>Ładowanie...</p>
	}
	else
	{
		@foreach (var product in products)
		{
			<p>@product.Name</p>
		}
	}
	
	@code {
		private List<Product> products;
		
		protected override async Task OnInitializedAsync()
		{
			await Task.Delay(1500); // Symulacja
			products = new List<Product>
			{
				new Product { Name = "Product 1" },
				new Product { Name = "Product 2" }
			};
		}
	}
\end{lstlisting}

\section{Struktura projektu Blazor Web App}

\subsection{Komponenty}
\begin{description}
	\item[Server] Host, API, SSR
	\item[Client] WebAssembly (komponenty interaktywne)
	\item[Shared] Modele, DTO, interfejsy usług
\end{description}

\subsection{Program. cs - Server}
\begin{lstlisting}
	var builder = WebApplicationBuilder.CreateBuilder(args);
	
	builder.Services
	.AddRazorComponents()
	.AddInteractiveServerComponents()
	.AddInteractiveWebAssemblyComponents();
	
	builder.Services.AddScoped<GameService>();
	
	var app = builder.Build();
	
	app.UseStaticFiles();
	app.UseRouting();
	app.MapRazorComponents<App>()
	.AddInteractiveServerRenderMode()
	.AddInteractiveWebAssemblyRenderMode();
	
	app.Run();
\end{lstlisting}

\section{Formularze}

\subsection{EditForm}
\begin{lstlisting}
	@page "/contacts/edit"
	@rendermode InteractiveServer
	
	<h1>Nowy kontakt</h1>
	
	<EditForm Model="contact" OnValidSubmit="HandleSubmit">
	<DataAnnotationsValidator />
	<ValidationSummary />
	
	<div>
	<label>Imię:</label>
	<InputText @bind-Value="contact.FirstName" />
	</div>
	
	<div>
	<label>Email:</label>
	<InputEmail @bind-Value="contact.Email" />
	</div>
	
	<button type="submit">Zapisz</button>
	</EditForm>
	
	@code {
		private Contact contact = new();
		
		private async Task HandleSubmit()
		{
			await contactService.SaveAsync(contact);
		}
	}
\end{lstlisting}

\subsection{SSR static formularze}
\begin{lstlisting}
	@page "/contact"
	
	<h1>Kontakt</h1>
	
	<form method="post">
	<input type="hidden" name="FormName" value="Contact" />
	
	<div>
	<label>Imię:</label>
	<input type="text" name="firstName" required />
	</div>
	
	<button type="submit">Wyślij</button>
	</form>
	
	@code {
		[SupplyParameterFromForm(FormName = "Contact")]
		private string FirstName { get; set; }
		
		public async Task OnPostAsync()
		{
			if (FirstName != null)
			{
				// Przetwórz dane
			}
		}
	}
\end{lstlisting}

\section{Walidacja}

\subsection{Data Annotations}
\begin{lstlisting}
	public class Contact
	{
		[Required(ErrorMessage = "Imię jest wymagane")]
		[MinLength(2, ErrorMessage = "Min 2 znaki")]
		public string FirstName { get; set; }
		
		[Required]
		[EmailAddress]
		public string Email { get; set; }
	}
\end{lstlisting}

\subsection{Custom validator}
\begin{lstlisting}
	public class CustomValidator : ComponentBase
	{
		private EditContext editContext;
		
		[CascadingParameter]
		private EditContext EditContext
		{
			get => editContext;
			set
			{
				editContext = value;
				editContext?.AddAsyncValidator(this);
			}
		}
		
		public async Task ValidateAsync(
		ValidationContext context)
		{
			// Custom validacja
		}
	}
\end{lstlisting}

\section{EF Core w Blazor}

\subsection{DbContext}
\begin{lstlisting}
	public class GameContext : DbContext
	{
		public DbSet<Game> Games { get; set; }
		
		protected override void OnConfiguring(
		DbContextOptionsBuilder options)
		{
			options. UseSqlServer(
			"Server=localhost;Database=Games;.. .");
		}
		
		protected override void OnModelCreating(
		ModelBuilder modelBuilder)
		{
			modelBuilder.Entity<Game>(). HasData(
			new Game { Id = 1, Title = "Elden Ring" },
			new Game { Id = 2, Title = "Baldur's Gate 3" }
			);
		}
	}
\end{lstlisting}

\subsection{Migracje}
\begin{lstlisting}
	dotnet ef migrations add InitialCreate
	dotnet ef database update
\end{lstlisting}

\subsection{Rejestracja w DI}
\begin{lstlisting}
	builder.Services.AddDbContext<GameContext>(options =>
	options.UseSqlServer(
	builder.Configuration.GetConnectionString("Default")));
\end{lstlisting}

\section{Service Layer}

\subsection{Server - bezpośredni dostęp do DbContext}
\begin{lstlisting}
	public interface IGameService
	{
		Task<List<Game>> GetAllAsync();
		Task<Game> GetByIdAsync(int id);
		Task CreateAsync(Game game);
	}
	
	public class GameService : IGameService
	{
		private readonly GameContext context;
		
		public GameService(GameContext context)
		{
			this.context = context;
		}
		
		public async Task<List<Game>> GetAllAsync()
		{
			return await context.Games.ToListAsync();
		}
		
		public async Task CreateAsync(Game game)
		{
			context.Games.Add(game);
			await context.SaveChangesAsync();
		}
	}
\end{lstlisting}

\subsection{Client - HttpClient}
\begin{lstlisting}
	public class ClientGameService : IGameService
	{
		private readonly HttpClient httpClient;
		
		public ClientGameService(HttpClient httpClient)
		{
			this.httpClient = httpClient;
		}
		
		public async Task<List<Game>> GetAllAsync()
		{
			return await httpClient.GetFromJsonAsync<List<Game>>(
			"/api/games");
		}
		
		public async Task CreateAsync(Game game)
		{
			await httpClient.PostAsJsonAsync("/api/games", game);
		}
	}
\end{lstlisting}

\section{Komponenty CRUD}

\subsection{Lista z stream renderingiem}
\begin{lstlisting}
	@page "/games"
	@rendermode InteractiveServer
	@inject IGameService gameService
	
	<h1>Games</h1>
	
	<button @onclick="NavigateToCreate">Add New</button>
	
	@if (games == null)
	{
		<p>Loading...</p>
	}
	else
	{
		<table>
		<thead>
		<tr>
		<th>Title</th>
		<th>Actions</th>
		</tr>
		</thead>
		<tbody>
		@foreach (var game in games)
		{
			<tr>
			<td>@game.Title</td>
			<td>
			<button @onclick='() => NavigateToEdit(game. Id)'>
			Edit
			</button>
			<button @onclick='() => Delete(game.Id)'>
			Delete
			</button>
			</td>
			</tr>
		}
		</tbody>
		</table>
	}
	
	@code {
		private List<Game> games;
		
		protected override async Task OnInitializedAsync()
		{
			games = await gameService.GetAllAsync();
		}
		
		private void NavigateToCreate()
		{
			// Navigate to create page
		}
		
		private async Task Delete(int id)
		{
			await gameService.DeleteAsync(id);
			games = await gameService.GetAllAsync();
		}
	}
\end{lstlisting}

\subsection{Edycja - Auto render mode}
\begin{lstlisting}
	@page "/games/edit"
	@page "/games/edit/{id:int}"
	@rendermode InteractiveAuto
	@inject IGameService gameService
	
	<h1>@(game.Id == 0 ? "Add" : "Edit") Game</h1>
	
	<EditForm Model="game" OnValidSubmit="Save">
	<DataAnnotationsValidator />
	<ValidationSummary />
	
	<InputText @bind-Value="game.Title" 
	placeholder="Title" />
	
	<button type="submit">Save</button>
	</EditForm>
	
	@code {
		[Parameter]
		public int Id { get; set; }
		
		private Game game = new();
		
		protected override async Task OnInitializedAsync()
		{
			if (Id > 0)
			{
				game = await gameService.GetByIdAsync(Id);
			}
		}
		
		private async Task Save()
		{
			if (game.Id == 0)
			await gameService.CreateAsync(game);
			else
			await gameService.UpdateAsync(game);
		}
	}
\end{lstlisting}

\section{PWA (WebAssembly)}

\subsection{Service Worker}
\begin{itemize}
	\item Cache zasobów offline
	\item Synchronizacja w tle
	\item Push notyfikacje
\end{itemize}

\subsection{Włączenie PWA}
Blazor WebAssembly automatycznie obsługuje PWA.  Dodaj manifest i service worker. 

\section{Pre-rendering}

\subsection{Włączone pre-rendering}
\begin{lstlisting}
	@rendermode new InteractiveServerRenderMode(prerender: true)
\end{lstlisting}

\subsection{Wyłączone pre-rendering}
\begin{lstlisting}
	@rendermode new InteractiveServerRenderMode(prerender: false)
\end{lstlisting}

\section{Pytania kontrolne}

\begin{enumerate}
	\item Jakie są główne tryby renderowania w Blazor? 
	\item Kiedy wybrać Static SSR, a kiedy Interactive? 
	\item Co to jest stream rendering i jakie są jego korzyści?
	\item Jak zaimplementować formularz w Blazor? 
	\item Jakie są różnice między EditForm a HTML form?
	\item Jak zintegrować EF Core z Blazor? 
	\item Co to jest PWA i kiedy go używać?
	\item Jaka jest różnica między pre-rendering włączonym a wyłączonym?
	\item Jak obsługiwać walidację w formularzach?
\end{enumerate}