\chapter{Tworzenie API REST}

\section{Wstęp}
REST (Representational State Transfer) to architektura do tworzenia usług sieciowych. API REST używa standardowych czasowników HTTP i statusów do komunikacji między klientem a serwerem.

\section{Stworzenie nowego Web API w Visual Studio}

\subsection{Inicjalizacja projektu}
\begin{lstlisting}
	dotnet new webapi -n ShopAPI. Api
	cd ShopAPI.Api
	code .
	dotnet run
\end{lstlisting}

\subsection{Gdzie uruchomić się aplikacja}
\texttt{https://localhost:7294/swagger/index.html}

\section{HTTPS i certyfikat SSL}

\subsection{Weryfikacja certyfikatu}
\begin{lstlisting}
	dotnet dev-certs https --check
	dotnet dev-certs https --trust
\end{lstlisting}

\subsection{Omijanie zabezpieczenia SSL w Chrome}
\begin{enumerate}
	\item Wpisz: \texttt{chrome://flags/\#allow-insecure-localhost}
	\item Ustaw na "Enabled"
	\item Zrestartuj Chrome
\end{enumerate}

\section{Testowanie API}

\subsection{Narzędzia testowania}
\begin{description}
	\item[Swagger] Interfejs webowy, intuicyjny, bezpośrednio w aplikacji
	\item[curl] Minimalistyczne, działające z konsoli, idealne dla skryptów
	\item[Postman] Rozbudowane, możliwość zapisywania kolekcji
	\item[Pliki . http] Native w VS Code, idealnie dla . NET developerów
	\item[Przeglądarka] Tylko dla GET, szybka weryfikacja
\end{description}

\subsection{Przykład z Swagger}
API automatycznie generuje dokumentację na \texttt{/swagger}

\subsection{Przykład z curl}
\begin{lstlisting}
	# GET
	curl https://localhost:7294/api/cities
	
	# POST
	curl -X POST https://localhost:7294/api/cities \
	-H "Content-Type: application/json" \
	-d '{"name":"Warsaw","country":"Poland"}'
\end{lstlisting}

\section{Czasowniki HTTP i dobre praktyki REST}

\subsection{Podstawowe metody}
\begin{table}[h]
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Metoda} & \textbf{Opis} & \textbf{Przykład} \\
		\hline
		GET & Pobieranie danych & GET /api/cities \\
		POST & Dodawanie nowych danych & POST /api/cities \\
		PUT & Aktualizacja całego zasobu & PUT /api/cities/1 \\
		PATCH & Częściowa aktualizacja & PATCH /api/cities/1 \\
		DELETE & Usunięcie zasobu & DELETE /api/cities/1 \\
		\hline
	\end{tabular}
\end{table}

\subsection{Zaawansowane metody}
\begin{description}
	\item[HEAD] Pobiera tylko nagłówki (sprawdzenie, czy zasób istnieje)
	\item[OPTIONS] Zwraca dostępne metody dla endpointu
\end{description}

\subsection{Idempotencja}
\begin{itemize}
	\item \textbf{Idempotentne}: GET, PUT, DELETE (wielokrotne wywołanie = ten sam efekt)
	\item \textbf{Nie idempotentne}: POST (za każdym razem tworzy nowy zasób)
\end{itemize}

\section{Przykład CitiesController}

\subsection{Implementacja endpointów}
\begin{lstlisting}
	[ApiController]
	[Route("api/[controller]")]
	public class CitiesController : ControllerBase
	{
		private static List<CityDto> cities = new();
		
		// GET /api/cities
		[HttpGet]
		public ActionResult<List<CityDto>> GetAll() 
		=> Ok(cities);
		
		// GET /api/cities/{id}
		[HttpGet("{id}")]
		public ActionResult<CityDto> GetById(int id)
		{
			var city = cities.FirstOrDefault(c => c.Id == id);
			if (city == null) return NotFound();
			return Ok(city);
		}
		
		// POST /api/cities
		[HttpPost]
		public ActionResult<CityDto> Create([FromBody] CityDto dto)
		{
			var newCity = new CityDto 
			{ 
				Id = cities.Count + 1, 
				Name = dto.Name, 
				Country = dto. Country 
			};
			cities.Add(newCity);
			return CreatedAtAction(nameof(GetById), 
			new { id = newCity. Id }, newCity);
		}
		
		// PUT /api/cities/{id}
		[HttpPut("{id}")]
		public IActionResult Update(int id, 
		[FromBody] CityDto dto)
		{
			var city = cities.FirstOrDefault(c => c.Id == id);
			if (city == null) return NotFound();
			
			city.Name = dto.Name;
			city.Country = dto.Country;
			return NoContent();
		}
		
		// PATCH /api/cities/{id}
		[HttpPatch("{id}")]
		public IActionResult PartialUpdate(int id, 
		[FromBody] JsonPatchDocument<CityDto> patch)
		{
			var city = cities.FirstOrDefault(c => c.Id == id);
			if (city == null) return NotFound();
			
			var cityDto = new CityDto 
			{ 
				Name = city.Name, 
				Country = city.Country 
			};
			patch.ApplyTo(cityDto);
			
			city.Name = cityDto.Name;
			city.Country = cityDto.Country;
			return NoContent();
		}
		
		// DELETE /api/cities/{id}
		[HttpDelete("{id}")]
		public IActionResult Delete(int id)
		{
			var city = cities.FirstOrDefault(c => c.Id == id);
			if (city == null) return NotFound();
			
			cities.Remove(city);
			return NoContent();
		}
	}
\end{lstlisting}

\section{Statusy HTTP}

\subsection{Statusy sukcesu}
\begin{table}[h]
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Kod} & \textbf{Znaczenie} & \textbf{Przykład} \\
		\hline
		200 & OK & Poprawne pobranie danych \\
		201 & Created & Nowy zasób utworzony \\
		204 & No Content & Operacja udana, brak danych w odpowiedzi \\
		\hline
	\end{tabular}
\end{table}

\subsection{Statusy błędów}
\begin{table}[h]
	\begin{tabular}{|l|l|l|}
		\hline
		\textbf{Kod} & \textbf{Znaczenie} & \textbf{Przykład} \\
		\hline
		400 & Bad Request & Zła składnia lub brakujące pole \\
		401 & Unauthorized & Brak autoryzacji (brak JWT tokena) \\
		403 & Forbidden & Brak uprawnień (user nie jest adminem) \\
		404 & Not Found & Zasób nie istnieje \\
		409 & Conflict & Konflikt danych \\
		500 & Server Error & Wyjątek w kodzie \\
		\hline
	\end{tabular}
\end{table}

\section{DTO i modele}

\subsection{Definicja DTO}
DTO (Data Transfer Object) to obiekt wymiany danych między API a klientem.

\subsection{Przykład}
\begin{lstlisting}
	public class CityDto
	{
		public int Id { get; set; }
		public string Name { get; set; }
		public string Country { get; set; }
	}
\end{lstlisting}

\subsection{Dlaczego DTO?}
\begin{itemize}
	\item Oddzielenie API od logiki biznesowej
	\item Bezpieczeństwo (nie wysyłamy całej encji z bazą)
	\item Elastyczność (łatwa zmiana struktury)
	\item Walidacja danych
\end{itemize}

\section{Schematy i Swagger}

\subsection{Generowanie dokumentacji}
Swagger automatycznie generuje \texttt{swagger.json} na \texttt{/swagger/v1/swagger.json}

\subsection{Wykorzystanie schematu}
\begin{itemize}
	\item Dokumentacja API dla frontend developerów
	\item Generowanie klienta automatycznie (NSwag, OpenAPI Generator)
	\item Walidacja zapytań
\end{itemize}

\section{Wysyłanie zapytań z aplikacji klienckiej}

\subsection{Konsola - przykład}
\begin{lstlisting}
	dotnet new console -n ShopAPI. Client
	cd ShopAPI.Client
	dotnet add package System.Net.Http.Json
	
	// Program.cs
	using System. Net.Http. Json;
	
	var client = new HttpClient();
	client.BaseAddress = new Uri("https://localhost:7294");
	
	// GET
	var cities = await client.GetFromJsonAsync<List<CityDto>>(
	"/api/cities");
	Console.WriteLine($"Miasta: {string.Join(", ", 
		cities.Select(c => c.Name))}");
	
	// POST
	var newCity = new CityDto 
	{ 
		Name = "Warsaw", 
		Country = "Poland" 
	};
	var response = await client.PostAsJsonAsync(
	"/api/cities", newCity);
	Console.WriteLine($"Dodano miasto, status: {response.StatusCode}");
\end{lstlisting}

\section{Autentykacja i autoryzacja}

\subsection{Flow OAuth 2.0 + PKCE}
\begin{enumerate}
	\item Użytkownik kliknie "Zaloguj się"
	\item Aplikacja generuje \texttt{code\_challenge} i \texttt{state}
	\item Redirect do providera (Google / Microsoft Entra ID)
	\item Provider zwraca \texttt{code}
	\item Aplikacja wymienia \texttt{code} na \texttt{access\_token}
	\item Aplikacja wysyła \texttt{access\_token} w nagłówku \texttt{Authorization: Bearer}
	\item API weryfikuje token i zwraca dane
\end{enumerate}

\subsection{Google Cloud Console}
\begin{enumerate}
	\item Utwórz OAuth consent screen
	\item Dodaj zakresy: \texttt{openid, email, profile}
	\item Utwórz OAuth Client ID
	\item Zanotuj: Client ID, Client Secret, Redirect URI
\end{enumerate}

\subsection{Microsoft Entra ID}
\begin{enumerate}
	\item Azure Portal → App registrations
	\item Zanotuj: Application ID, Tenant ID
	\item Dodaj Redirect URIs
	\item Włącz "ID tokens"
\end{enumerate}

\subsection{Integracja w . NET API}
\begin{lstlisting}
	builder
	.AddAuthentication(JwtBearer)
	.AddJwtBearer(options =>
	{
		options.Authority = 
		"https://login.microsoftonline.com/{tenant}/v2.0";
		options. Audience = "{client-id}";
	});
	
	[Authorize]
	[HttpGet]
	public ActionResult<List<CityDto>> GetAll() 
	=> Ok(cities);
\end{lstlisting}

\section{Paginacja i filtrowanie}

\subsection{Przykład}
\begin{lstlisting}
	// GET /api/cities? page=1&pageSize=10&country=Poland
	[HttpGet]
	public ActionResult<PagedResult<CityDto>> GetAll(
	int page = 1, 
	int pageSize = 10, 
	string?  country = null)
	{
		var query = cities.AsQueryable();
		
		if (!string.IsNullOrEmpty(country))
		query = query.Where(c => c.Country == country);
		
		var total = query.Count();
		var items = query
		.Skip((page - 1) * pageSize)
		. Take(pageSize)
		. ToList();
		
		return Ok(new PagedResult<CityDto>
		{
			Items = items,
			Total = total,
			Page = page,
			PageSize = pageSize
		});
	}
\end{lstlisting}

\section{Walidacja danych}

\subsection{Data Annotations}
\begin{lstlisting}
	public class CityDto
	{
		[Required(ErrorMessage = "Imię jest wymagane")]
		[MinLength(2)]
		public string Name { get; set; }
		
		[Required]
		public string Country { get; set; }
	}
\end{lstlisting}

\subsection{Walidacja automatyczna}
ASP.NET automatycznie waliduje na podstawie atrybutów i zwraca 400 Bad Request z szczegółami błędów.

\section{Pytania kontrolne}

\begin{enumerate}
	\item Jakie są podstawowe metody HTTP i ich zastosowania?
	\item Kiedy używać PUT, a kiedy PATCH?
	\item Jaka jest różnica między 200 a 201 a 204?
	\item Co to jest DTO i dlaczego go używamy?
	\item Jak obsługiwać błędy w API?
	\item Jakie są kroki OAuth 2.0 + PKCE flow?
	\item Jak zaimplementować autoryzację w API?
	\item Jak dodać paginację do endpointu?
\end{enumerate}