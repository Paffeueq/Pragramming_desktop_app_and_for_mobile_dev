Programowanie AI - Copilot, VS Code
MateriaÅ‚y wideo
â€¢	5 New VS Code AI Features & Settings You Need To Try Today
â€¢	How To Get Better AI Reponses from GitHub Copilot in Seconds!
â€¢	Turn ON these new VS Code AI features NOW! (v1.103)
â€¢	Grok Code Fast 1 in VS Code is Fast - Letâ€™s take a look
â€¢	Hello Claude Sonnet 4.5! This things is a BEAST!
â€¢	Background Coding Agents change EVERYTHING - 5 ways to use them today!
________________________________________
Tematy do poruszenia
1.	Agent Mode i jego zastosowania praktyczne
o	RÃ³Å¼nice miÄ™dzy klasycznym Copilotem a trybem Agent Mode.
o	Scenariusze, w ktÃ³rych warto uruchamiaÄ‡ agenta (np. build/test, dÅ‚ugotrwaÅ‚e zadania).
o	PorÃ³wnanie trybu interaktywnego i w peÅ‚ni automatycznego.
2.	Allow / Deny List â€“ bezpieczeÅ„stwo i kontrola
o	Rola listy dozwolonych komend w zapewnieniu bezpieczeÅ„stwa.
o	Jak unikaÄ‡ ryzyka przypadkowego wykonania niepoÅ¼Ä…danych poleceÅ„.
o	PrzykÅ‚ady praktyczne (dotnet build/test vs komendy niebezpieczne).
3.	ZarzÄ…dzanie limitami i wydajnoÅ›ciÄ… (Max Requests)
o	Jak limit requestÃ³w wpÅ‚ywa na pÅ‚ynnoÅ›Ä‡ pracy.
o	Praktyczne ustawienia w projektach Å›rednich i duÅ¼ych.
o	Kiedy warto zwiÄ™kszyÄ‡, a kiedy ograniczyÄ‡ limit.
4.	Copilot Instructions i personalizacja stylu pracy
o	Automatyczne generowanie instrukcji z projektu.
o	Dodawanie wÅ‚asnych reguÅ‚ i konwencji kodu.
o	Rozdzielanie zasad dla backendu i frontendu.
o	UÅ¼ycie instrukcji jako dokumentacji zespoÅ‚owej.
5.	Snooze Completions â€“ balans miÄ™dzy AI a samodzielnym kodowaniem
o	Kiedy warto wyciszyÄ‡ podpowiedzi Copilota.
o	PorÃ³wnanie efektywnoÅ›ci pracy z i bez asysty AI.
o	Ä†wiczenie Å›wiadomego programowania z przerwami od AI.
6.	Custom Chat Modes (Beast Mode i inne)
o	Czym sÄ… tryby czatu i jak je definiowaÄ‡ w repozytorium.
o	Jak rÃ³Å¼ne tryby wpÅ‚ywajÄ… na sposÃ³b rozwiÄ…zywania problemÃ³w przez AI.
o	PrzykÅ‚ady wÅ‚asnych trybÃ³w dopasowanych do zespoÅ‚u/projektu.
7.	Coding Agents â€“ nowa rola agenta jako wirtualnego wspÃ³Å‚programisty
o	Przypisywanie zadaÅ„ i issue do agenta.
o	Delegowanie PR i kontynuacja pracy w tle.
o	Code review od agenta â€“ ograniczenia i zalety.
o	Scenariusze wspÃ³Å‚pracy: czÅ‚owiek + agent.
8.	Integracja z GitHub Actions i workflow zespoÅ‚owym
o	Automatyzacja setupu Å›rodowiska (copilot-setup-steps.yml).
o	Dependabot i aktualizacje zaleÅ¼noÅ›ci.
o	Agents.mmd â€“ orkiestracja wielu agentÃ³w w projekcie.
9.	Statystyki uÅ¼ycia AI i refleksja nad produktywnoÅ›ciÄ…
o	Analiza AI vs typing â€“ co naprawdÄ™ daje Copilot.
o	Eksperymenty porÃ³wnawcze (samodzielne kodowanie vs z AI).
o	Jak wykorzystaÄ‡ dane statystyczne do poprawy efektywnoÅ›ci zespoÅ‚u.
10.	Modele AI i ich zarzÄ…dzanie
o	PrzeglÄ…d dostÄ™pnych modeli (GPT-5, GPT-5 mini).
o	Kryteria wyboru modelu do danego zadania.
o	Usuwanie starszych modeli i utrzymywanie spÃ³jnego Å›rodowiska.
11.	MCP Auto Start i narzÄ™dzia developerskie
o	Rola MCP w pracy Copilota.
o	Konfiguracja serwerÃ³w MCP i rozszerzeÅ„.
o	ZarzÄ…dzanie narzÄ™dziami, ktÃ³re sÄ… naprawdÄ™ potrzebne w projekcie.
12.	Najlepsze praktyki w pracy z AI w projekcie .NET
o	Konwencje kodu i ujednolicenie stylu w zespole.
o	Integracja AI w pipeline CI/CD.
o	Granice automatyzacji â€“ co warto zostawiÄ‡ programistom.
________________________________________
Ä†wiczenia
1. Terminal â€“ Allow / Deny List
1.	OtwÃ³rz swÃ³j projekt .NET w VS Code.
2.	WÅ‚Ä…cz agent mode i poproÅ› AI o zbudowanie projektu. ZwrÃ³Ä‡ uwagÄ™, Å¼e prosi o potwierdzenie.
3.	WejdÅº w Settings â†’ Copilot â†’ Experimental i skonfiguruj allow list.
o	dodaj dotnet build,
o	dodaj dotnet test.
4.	SprÃ³buj ponownie â€“ projekt powinien budowaÄ‡ siÄ™ i testowaÄ‡ automatycznie, bez pytania.
________________________________________
2. Max Requests
1.	W ustawieniach znajdÅº opcjÄ™ max requests.
2.	ZmieÅ„ domyÅ›lnÄ… wartoÅ›Ä‡ (20) np. na 100.
3.	Uruchom agent mode i zleÄ‡ AI dÅ‚uÅ¼sze zadanie â€“ np. wygenerowanie kilku endpointÃ³w API.
4.	ZauwaÅ¼, Å¼e teraz proces jest pÅ‚ynny i nie wymaga czÄ™stego potwierdzania.
________________________________________
3. Generate Instructions
1.	W Agent Mode Settings znajdÅº opcjÄ™ Generate Instructions.
2.	Uruchom generowanie â€“ Copilot przeskanuje caÅ‚y projekt i utworzy plik copilot-instructions.md.
3.	SprawdÅº, czy zawiera:
o	opis struktury projektu,
o	komendy budowania i uruchamiania,
o	konwencje kodu.
4.	Dodaj nowÄ… klasÄ™ i ponownie wygeneruj instrukcje. PorÃ³wnaj zmiany.
________________________________________
4. Snooze Completions
1.	Napisz prostÄ… klasÄ™ User w C#.
2.	ZauwaÅ¼ podpowiedzi (ghost text) Copilota.
3.	Kliknij ikonÄ™ Copilota w pasku statusu i wybierz Snooze na 5 minut.
4.	Kontynuuj pisanie kodu â€“ dziaÅ‚ajÄ… tylko podpowiedzi IntelliSense.
5.	Anuluj Snooze i sprawdÅº, Å¼e podpowiedzi Copilota wracajÄ….
________________________________________
5. Tryb Beast Mode
1.	OtwÃ³rz repozytorium copilot repo na GitHub.
2.	Skopiuj zawartoÅ›Ä‡ pliku z trybem Beast Mode (np. wersja od Burke Hollanda).
3.	W projekcie utwÃ³rz katalog .github/chat-modes i plik beast.json.
4.	Uruchom agent mode, wybierz tryb Beast Mode.
5.	PoproÅ› o dodanie endpointu API do zarzÄ…dzania uÅ¼ytkownikami.
6.	Obserwuj, jak AI rozbija zadanie na kroki i realizuje je sekwencyjnie.
________________________________________
6. Copilot Instructions i Customizacja
a) Dodawanie wÅ‚asnych instrukcji
1.	UtwÃ³rz folder .github i plik copilot-instructions.md.
2.	Dodaj wÅ‚asne reguÅ‚y, np.:
o	klasy i metody w PascalCase,
o	zmienne w camelCase,
o	DTO z atrybutami JSON,
o	proste komentarze w kodzie.
b) Automatyczne generowanie instrukcji
1.	OtwÃ³rz chat Copilota.
2.	Kliknij Customize chat â†’ Generate Instructions.
3.	Obejrzyj wygenerowane zasady â€“ sprawdÅº backend, frontend, komendy, konwencje.
c) Testowanie instrukcji
1.	W chat poproÅ› o dodanie nowego endpointu API dla uÅ¼ytkownikÃ³w.
2.	Zobacz, czy Copilot stosuje siÄ™ do ustalonych reguÅ‚ (np. PascalCase, JSON DTO).
d) Aktualizacja instrukcji
1.	Dodaj klasÄ™ Order.
2.	Ponownie wygeneruj instrukcje i sprawdÅº, jak zostaÅ‚y rozszerzone.
3.	Dodaj wÅ‚asne reguÅ‚y, np. walidacja zamÃ³wieÅ„.
e) Wersje rozbite
1.	W .github dodaj:
o	csharp-guidelines.md (zasady dla C#),
o	blazor-guidelines.md (zasady dla Blazora).
2.	SprawdÅº, czy Copilot stosuje inne reguÅ‚y w backendzie i frontendzie.
________________________________________
7. ZarzÄ…dzanie modelami AI
1.	W VS Code 1.103 otwÃ³rz model selector.
2.	Wybierz GPT-5 i sprawdÅº GPT-5 mini.
3.	W Manage Models usuÅ„ starsze modele (np. GPT-4).
4.	SprawdÅº, Å¼e lista modeli zawiera tylko wybrane przez Ciebie.
________________________________________
8. MCP Auto Start i narzÄ™dzia
1.	W ustawieniach znajdÅº MCP Auto Start i ustaw tryb (np. always).
2.	OtwÃ³rz Configure Tools â€“ przejrzyj wbudowane narzÄ™dzia, wyÅ‚Ä…cz nieuÅ¼ywane.
3.	Dodaj MCP server i sprawdÅº jego widocznoÅ›Ä‡ w Extensions â†’ MCP servers.
________________________________________
9. Statystyki uÅ¼ycia AI
1.	WÅ‚Ä…cz opcjÄ™ AI Stats.
2.	W dolnym rogu sprawdÅº wykres AI vs typing z 24h.
3.	ZrÃ³b eksperyment: koduj 5 minut samodzielnie, potem 5 minut z Copilotem.
4.	PorÃ³wnaj rÃ³Å¼nice w statystykach.
________________________________________
10. Task Lists (To-Do w czacie)
1.	Wpisz w chat: â€Dodaj stronÄ™ z formularzem kontaktowymâ€.
2.	Copilot wygeneruje listÄ™ krokÃ³w (task list).
3.	Obserwuj, jak lista aktualizuje siÄ™ podczas pracy (UI, CSS, endpoint).
4.	Po zakoÅ„czeniu sprawdÅº, czy wszystkie kroki oznaczone sÄ… jako wykonane.
________________________________________
11. Background Agents i sesje w tle
1.	WÅ‚Ä…cz w ustawieniach Agent Sessions (UI integration).
2.	OtwÃ³rz panel Agent Sessions â€“ sprawdÅº aktywne sesje.
3.	Dodaj zadanie (np. raport) i oddeleguj je do coding agent.
4.	SprawdÅº na GitHub, Å¼e powstaÅ‚ automatyczny pull request.
5.	Kontynuuj pracÄ™ lokalnie, podczas gdy agent dziaÅ‚a w tle.
________________________________________
12. Coding Agents â€“ praca praktyczna
a) Przypisywanie issue do agenta
1.	UtwÃ³rz issue w GitHub: â€DodaÄ‡ skeleton loading na stronie logowaniaâ€.
2.	Przypisz je do Copilot.
3.	Obserwuj, jak agent tworzy branch i PR.
b) Delegowanie pracy z dowolnego brancha
1.	W VS Code wybierz dowolny branch.
2.	W panelu agenta kliknij +, dodaj zadanie.
3.	SprawdÅº, Å¼e Copilot tworzy nowy branch, sesjÄ™ i PR.
c) Kontynuowanie pracy agenta
1.	UtwÃ³rz branch feature/tools-refactor i wprowadÅº zmiany.
2.	W czacie wpisz: â€UzupeÅ‚nij dokumentacjÄ™ i READMEâ€.
3.	Kliknij Delegate to Coding Agent i uwzglÄ™dnij lokalne zmiany.
4.	Obserwuj, Å¼e agent kontynuuje pracÄ™ w tle.
d) WspÃ³Å‚praca z agentem przy PR
1.	UtwÃ³rz pull request z duÅ¼Ä… zmianÄ….
2.	W komentarzu dodaj: â€@copilot napraw null reference w APIâ€.
3.	Obserwuj, jak agent aktualizuje kod i PR.
e) Code review od agenta
1.	UtwÃ³rz PR z maÅ‚Ä… zmianÄ… (np. Console.WriteLine).
2.	Dodaj Copilota jako reviewera.
3.	SprawdÅº sugestie (np. uÅ¼ycie ILogger).
________________________________________
13. Dependabot i automatyczne aktualizacje
1.	W repo wÅ‚Ä…cz Dependabot security updates.
2.	Skonfiguruj dependabot.yml (aktualizacje NuGet i SDK raz w tygodniu).
3.	Poczekaj na automatyczne PR.
4.	Przejrzyj zmiany i zaakceptuj.
________________________________________
14. Najlepsze praktyki i konfiguracja Å›rodowiska
1.	W .github/workflows utwÃ³rz copilot-setup-steps.yml:
o	instalacja .NET 9,
o	restore paczek,
o	Aspire CLI lub workload MAUI.
2.	W .github dodaj copilot-instructions.md:
o	architektura projektu,
o	konwencje kodu,
o	zasady CSS.
3.	(Opcjonalnie) dodaj agents.mmd dla wielu agentÃ³w.

â€¢	Home
â€¢	Research
â€¢	Teaching
â€¢	Contact
Tworzenie API REST
MateriaÅ‚y wideo
â€¢	Explore, Test, & Debug API Endpoints in Visual Studio Faster Than Ever!
â€¢	Faster API Development in Visual Studio is Here! Say Hello to .http/.rest Files!
â€¢	.NET 9 Web API & Entity Framework ğŸš€ Full Course: CRUD, Code-First Migrations & SQL Server
â€¢	.NET 7 Minimal API for Beginners ğŸš€ Full CRUD in 10 Minutes!
â€¢	Connect from your Blazor app to your API
â€¢	Configure Blazor WebAssembly with Entra ID (.NET 8)
________________________________________
Tematy do poruszenia
1.	Stworzenie nowego Web API w Visual Studio
2.	Uruchomienie API â€“ omijanie zabezpieczenia SSL w Chrome:
o	w przeglÄ…darce wpisaÄ‡ chrome://flags/#allow-insecure-localhost i ustawiÄ‡ na Enabled
o	omÃ³wienie generowania certyfikatÃ³w SSL deweloperskich
3.	Testowanie API:
o	w Swaggerze
o	w curlu â€“ mini program do testowania API w konsoli
o	w Postmanie â€“ rozbudowany program do testowania API
o	w przeglÄ…darce
o	w Visual Studio uÅ¼ywajÄ…c plikÃ³w .http
4.	OmÃ³wienie czasownikÃ³w HTTP i zasady dziaÅ‚ania kontrolerÃ³w â€“ np. na przykÅ‚adzie WeatherForecastController
5.	PoÅ‚Ä…czenie siÄ™ z API i uÅ¼ycie schematÃ³w (models, DTOs, contracts)
6.	Autentykacja i autoryzacja (OAuth 2.0 / OpenID Connect): logowanie przez Google i Microsoft Entra ID (tenant, Application/Client ID, Secret, Redirect URI, wymiana kodu na token)
________________________________________
Ä†wiczenia
1. Stworzenie projektu Web API
dotnet new webapi -n ShopAPI.Api
cd ShopAPI.Api
code .
dotnet run
Test startowy: https://localhost:7294/swagger/index.html
________________________________________
2. Certyfikat developerski i HTTPS
â€¢	HTTPS dziaÅ‚a od poczÄ…tku, nawet w trybie lokalnym.
â€¢	Certyfikat developerski chroni transmisjÄ™ w Å›rodowisku deweloperskim.
dotnet dev-certs https --check
dotnet dev-certs https --trust
Chrome â†’ chrome://flags/#allow-insecure-localhost â†’ Enabled
________________________________________
3. Testowanie API
1.	Swagger
2.	curl
3.	Postman
4.	Pliki .http w VS Code
5.	PrzeglÄ…darka (dla GET)
________________________________________
4. Czasowniki HTTP i dobre praktyki REST
REST korzysta z kilku podstawowych metod, ale warto znaÄ‡ ich szerszy zestaw:
â€¢	GET â€“ pobieranie danych
â€¢	POST â€“ dodawanie nowych danych
â€¢	PUT â€“ aktualizacja caÅ‚ego zasobu
â€¢	PATCH â€“ czÄ™Å›ciowa aktualizacja (np. tylko jednego pola)
â€¢	DELETE â€“ usuniÄ™cie zasobu
â€¢	HEAD â€“ pobiera tylko nagÅ‚Ã³wki (np. do sprawdzenia, czy zasÃ³b istnieje)
â€¢	OPTIONS â€“ zwraca, jakie metody sÄ… dostÄ™pne dla danego endpointu
________________________________________
Ä†wiczenie 1 â€“ proste przykÅ‚ady
W CitiesController utwÃ³rz endpointy:
1.	GET /api/cities â†’ pobiera wszystkie miasta
2.	GET /api/cities/{id} â†’ pobiera jedno miasto
3.	POST /api/cities â†’ dodaje nowe miasto
4.	PUT /api/cities/{id} â†’ aktualizuje caÅ‚e miasto
5.	PATCH /api/cities/{id} â†’ zmienia tylko jedno pole (np. Country)
6.	DELETE /api/cities/{id} â†’ usuwa miasto
7.	HEAD /api/cities/{id} â†’ sprawdza, czy miasto istnieje (status 200/404)
8.	OPTIONS /api/cities â†’ zwraca listÄ™ dostÄ™pnych metod (Allow: GET, POST, PUT, PATCH, DELETE)
________________________________________
5. DTO i modele
public class CityDto 
{
    public string Name { get; set; }
    public string Country { get; set; }
}
OmÃ³w:
â€¢	DTO = obiekt wymiany danych
â€¢	oddziela API od logiki biznesowej
________________________________________
6. Statusy HTTP â€“ praktyczne scenariusze
Kod	Znaczenie	PrzykÅ‚ad
200 OK	poprawne pobranie	GET miast
201 Created	nowy zasÃ³b utworzony	POST miasto
204 No Content	usuniÄ™to, brak treÅ›ci	DELETE
400 Bad Request	zÅ‚a skÅ‚adnia danych	POST bez pola Name
401 Unauthorized	brak autoryzacji	brak JWT tokena
403 Forbidden	uÅ¼ytkownik nie ma uprawnieÅ„	np. zwykÅ‚y user prÃ³buje usunÄ…Ä‡ admina
404 Not Found	zasÃ³b nie istnieje	GET /cities/999
409 Conflict	konflikt danych	prÃ³ba dodania istniejÄ…cego miasta
500 Internal Server Error	bÅ‚Ä…d serwera	wyjÄ…tek w kodzie
ğŸ‘‰ Ä†wiczenie: w POST zwrÃ³Ä‡ 201 Created z nagÅ‚Ã³wkiem Location. ğŸ‘‰ Ä†wiczenie: w PUT zwrÃ³Ä‡ 404, jeÅ›li miasto nie istnieje. ğŸ‘‰ Ä†wiczenie: w PATCH zwrÃ³Ä‡ 409, jeÅ›li prÃ³ba zmiany koliduje z innymi danymi.
________________________________________
7. Schematy i generowanie klienta
â€¢	Swagger â†’ swagger.json zawiera definicje endpointÃ³w i modeli.
â€¢	MoÅ¼na generowaÄ‡ klienta automatycznie (NSwag, OpenAPI Generator).
ğŸ‘‰ Ä†wiczenie:
1.	OtwÃ³rz https://localhost:7294/swagger/v1/swagger.json.
2.	ZnajdÅº definicjÄ™ CityDto.
3.	PokaÅ¼, Å¼e na tej podstawie moÅ¼na wygenerowaÄ‡ klasÄ™ klienta w C#.
________________________________________
8. WysyÅ‚anie zapytaÅ„ do API z aplikacji klienckiej
Ä†wiczenie â€“ prosta aplikacja konsolowa
1.	UtwÃ³rz nowy projekt:
2.	dotnet new console -n ShopAPI.Client
3.	cd ShopAPI.Client
4.	Dodaj pakiet:
5.	dotnet add package System.Net.Http.Json
6.	W Program.cs:
7.	using System.Net.Http.Json;
8.	
9.	var client = new HttpClient();
10.	client.BaseAddress = new Uri("https://localhost:7294");
11.	
12.	// GET
13.	var cities = await client.GetFromJsonAsync<List<CityDto>>("/api/cities");
14.	Console.WriteLine($"Miasta: {string.Join(", ", cities.Select(c => c.Name))}");
15.	
16.	// POST
17.	var newCity = new CityDto { Name = "Warsaw", Country = "Poland" };
18.	var response = await client.PostAsJsonAsync("/api/cities", newCity);
19.	Console.WriteLine($"Dodano miasto, status: {response.StatusCode}");
________________________________________
9. Ä†wiczenia dodatkowe â€“ â€REST w realnym Å›wiecieâ€
1. Paginacja i filtrowanie
â€¢	GET /api/cities?page=1&pageSize=10
â€¢	GET /api/cities?country=Poland
â€¢	omÃ³w, dlaczego nie zwracamy od razu caÅ‚ej bazy.
2. Walidacja danych
â€¢	Dodaj [Required] do CityDto.Name.
â€¢	OmÃ³w walidacjÄ™ automatycznÄ… i status 400.
3. Idempotencja metod
â€¢	GET, PUT, DELETE sÄ… idempotentne (wielokrotne wywoÅ‚anie daje ten sam efekt).
â€¢	POST nie jest (dodaje za kaÅ¼dym razem nowy obiekt).
4. HATEOAS â€“ linki w odpowiedzi
â€¢	W GET /cities/{id} oprÃ³cz danych zwrÃ³Ä‡ linki do:
o	PUT (edycja),
o	DELETE (usuniÄ™cie).
â€¢	DziÄ™ki temu klient â€wieâ€, jakie akcje sÄ… moÅ¼liwe.
________________________________________
10. Autentykacja i autoryzacja (OAuth 2.0 / OpenID Connect)
Podstawy:
â€¢	Flow: Authorization Code + PKCE (dla SPA/native) lub Authorization Code (dla aplikacji serwerowych).
â€¢	Kluczowe elementy: Tenant, Client/Application ID, Client Secret (dla â€confidential clientsâ€), Redirect URI, Scopes (openid, profile, email), Token endpoints.
â€¢	Logowanie w przeglÄ…darce â†’ kod autoryzacyjny â†’ wymiana na tokeny (access_token, id_token, refresh_token).
Google (Google Cloud Console):
1.	UtwÃ³rz OAuth consent screen (External/Internal), dodaj zakresy: openid, email, profile.
2.	UtwÃ³rz OAuth Client ID: typ (Web/SPA/Android/iOS), ustaw Redirect URI (np. https://localhost:7294/signin-oidc albo dla SPA: http://localhost:5173/callback).
3.	Zanotuj: Client ID, Client Secret (jeÅ›li wymagane), Redirect URIs.
4.	Autoryzacja:
o	Authorize endpoint: https://accounts.google.com/o/oauth2/v2/auth
o	Token endpoint: https://oauth2.googleapis.com/token
o	PrzykÅ‚ad Å¼Ä…dania (PKCE, skrÃ³towo):
ï‚§	GET authorize z parametrami: client_id, redirect_uri, response_type=code, scope=openid email profile, code_challenge, code_challenge_method=S256, state.
ï‚§	Wymiana kodu: POST do token endpoint z code, client_id, redirect_uri, code_verifier (+ client_secret dla confidential).
5.	Weryfikacja id_token (JWT) podpisu i aud, iss.
Microsoft Entra ID (Azure Portal):
1.	Tenant: zapis Directory (tenant) ID.
2.	App registrations: zarejestruj aplikacjÄ™, dodaj Redirect URIs, wÅ‚Ä…cz â€ID tokensâ€.
3.	Zanotuj: Application (client) ID, Directory (tenant) ID, Client Secret (jeÅ›li potrzebny).
4.	Endpoints (v2.0):
o	Authorize: https://login.microsoftonline.com/{tenant}/oauth2/v2.0/authorize
o	Token: https://login.microsoftonline.com/{tenant}/oauth2/v2.0/token
5.	Scope: openid profile email (+ offline_access dla refresh), dla API: api://<app-id>/.<scope> lub Microsoft Graph: https://graph.microsoft.com/.default.
6.	UÅ¼yj PKCE dla public clients; dla confidential doÅ‚Ä…cz client_secret.
Integracja w .NET API (skrÃ³t):
â€¢	API zwykle weryfikuje JWT (Bearer) zamiast wykonywaÄ‡ interaktywny login.
â€¢	Konfiguracja (Minimal API):
o	AddAuthentication(JwtBearer).AddJwtBearer z Authority (np. Entra: https://login.microsoftonline.com/{tenant}/v2.0 lub Google: https://accounts.google.com) i Audience (Client ID / API App ID URI).
â€¢	Klient (SPA/Native) wykonuje login przez przeglÄ…darkÄ™ i przekazuje access_token w Authorization: Bearer <token>.
Ä†wiczenia:
â€¢	Skonfiguruj aplikacjÄ™ w Entra ID i zaloguj uÅ¼ytkownika przez Authorization Code + PKCE, wyÅ›wietl id_token claims (sub, name, email).
â€¢	Skonfiguruj login przez Google, odbierz code, wymieÅ„ na access_token, zweryfikuj id_token.
â€¢	Dodaj do API middleware JWT Bearer i zabezpiecz endpointy [Authorize].
________________________________________
â† PowrÃ³t do planu zajÄ™Ä‡
ğŸ’»ğŸ’¼ğŸ“§
Â© 2025 Tomasz LeÅ› | Warsaw University of Technology

â€¢	Home
â€¢	Research
â€¢	Teaching
â€¢	Contact
Tworzenie aplikacji typu MVC i MVVM
MateriaÅ‚y
â€¢	(MVVM) What is the MVVM pattern, What benefits does MVVM have? â€“ https://www.youtube.com/watch?v=AXpTeiWtbC8
â€¢	
(MAUI) Learn .NET MAUI - Full Course for Beginners	Build cross-platform apps in C# â€“ https://www.youtube.com/watch?v=DuNLR_NJv8U
â€¢	Dokumentacja:
o	ASP.NET Core MVC â€“ https://learn.microsoft.com/aspnet/core/mvc
o	.NET MAUI â€“ https://learn.microsoft.com/dotnet/maui
o	WPF â€“ https://learn.microsoft.com/dotnet/desktop/wpf
o	CommunityToolkit.Mvvm â€“ https://learn.microsoft.com/dotnet/communitytoolkit/mvvm/
â€¢	Repo przykÅ‚adowe (oficjalne): https://github.com/dotnet/maui / https://github.com/CommunityToolkit/dotnet
________________________________________
Tematy do poruszenia
1.	Dlaczego architektura w aplikacjach .NET MAUI?
o	Oddzielenie warstw (UI, logika prezentacji, logika biznesowa).
o	UÅ‚atwione testowanie (ViewModel bez zaleÅ¼noÅ›ci od UI).
o	Åatwiejsze utrzymanie i rozwÃ³j projektu (czystszy kod, mniejsza iloÅ›Ä‡ duplikacji).
o	Eliminacja problemÃ³w z podejÅ›ciem code-behind â€“ zdarzenia i logika w widoku powodujÄ… tight coupling i trudnoÅ›Ä‡ w testach.
2.	PrzeglÄ…d wzorcÃ³w: MVC vs MVVM
o	MVC (ASP.NET Core) â€“ Controller poÅ›redniczy miÄ™dzy Modelem a Widokiem (HTML / Razor).
o	MVVM (WPF / MAUI) â€“ ViewModel = stan + logika prezentacji + INotifyPropertyChanged.
3.	Data Binding
o	Tryby: OneWay, TwoWay, OneTime.
o	x:DataType â†’ compiled bindings (lepsza wydajnoÅ›Ä‡, IntelliSense).
o	WÅ‚asnoÅ›ci i INotifyPropertyChanged.
4.	CommunityToolkit.Mvvm
o	ObservableObject, [ObservableProperty], [RelayCommand].
o	Source Generators â€“ eliminacja boilerplate.
5.	Commands vs event handlers
o	ICommand, [RelayCommand], CanExecute (np. IsBusy).
o	Zalety uÅ¼ywania Command zamiast eventÃ³w w UI.
6.	Model vs DTO vs Entity
o	Rozdzielenie obiektÃ³w domenowych, transferowych i mapowanych z bazy.
o	Unikanie mieszania warstw danych z UI.
7.	Walidacja i konwersje
o	ValueConverter, MultiBinding.
o	ValidationAttributes lub FluentValidation.
8.	Stylizacja i zasoby
o	ResourceDictionary, globalne i lokalne style.
o	ObsÅ‚uga jasnego/ciemnego motywu (AppThemeBinding).
o	Ikony, fonty, obrazy (SVG, PNG, TTF/OTF).
9.	Nawigacja
o	MAUI Shell: Routing, Flyout, TabBar, GoToAsync.
o	WPF: NavigationService / Frame.
o	Rejestrowanie tras i przekazywanie parametrÃ³w.
10.	Integracja z API systemÃ³w
o	MAUI Essentials: Connectivity, Geolocation, czujniki, kamera, powiadomienia.
o	Natywne API Android/iOS/macOS/Windows w C#.
o	Kompilacja warunkowa #if ANDROID / #if IOS.
11.	RÃ³Å¼nice .NET MAUI vs WPF
o	Platformy: MAUI (Android, iOS, Windows, macOS) vs WPF (Windows).
o	Single Project (MAUI) vs klasyczny desktop (WPF).
o	Handlers (MAUI) vs Dependency Properties (WPF).
o	Lifecycle:
ï‚§	W MAUI (mobile) aplikacja dziaÅ‚a w cyklu Å¼ycia urzÄ…dzenia: uruchomienie (OnStart), przejÅ›cie w tÅ‚o (OnSleep / suspend), wznowienie (OnResume).
ï‚§	Na Android/iOS wymagane sÄ… teÅ¼ obsÅ‚ugi uprawnieÅ„ (kamera, lokalizacja).
ï‚§	W WPF aplikacja desktopowa dziaÅ‚a inaczej â€“ brak stanÃ³w â€uÅ›pieniaâ€ typowych dla urzÄ…dzeÅ„ mobilnych.
o	Dialekty XAML â€“ podobne, ale rÃ³Å¼ne kontrolki i przestrzenie nazw.
o	Hot Reload wieloplatformowy vs desktopowy.
12.	Kiedy wybraÄ‡ WPF, a kiedy MAUI
o	MAUI â€“ gdy aplikacja ma dziaÅ‚aÄ‡ na wielu platformach (Android, iOS, Windows, macOS).
o	WPF â€“ gdy aplikacja jest typowo desktopowa (Windows), istnieje duÅ¼a baza kodu legacy lub potrzeba specyficznych integracji z Windows.
13.	TestowalnoÅ›Ä‡
o	Testy jednostkowe ViewModeli (brak UI).
o	Mockowanie serwisÃ³w (HttpClient, repozytoria).
o	Dependency Injection: MauiProgram.Services w MAUI / zewnÄ™trzny kontener w WPF.
14.	Mechanizmy produktywnoÅ›ci
o	XAML Hot Reload, C# Hot Reload.
o	Live Preview, Live Visual Tree.
o	Debugowanie i breakpoints na wielu platformach.
________________________________________
Ä†wiczenia
1. Szybki start â€“ projekt MVC (backend)
dotnet new mvc -n DemoMvc
cd DemoMvc
dotnet run
â€¢	Uruchom aplikacjÄ™ i wejdÅº na wskazany adres w przeglÄ…darce.
â€¢	Obejrzyj strukturÄ™ katalogÃ³w: /Controllers, /Views, /Models.
â€¢	Dodaj prosty kontroler HelloController i akcjÄ™ Index, ktÃ³ra zwrÃ³ci np. View("Hello").
â€¢	Zrozum przepÅ‚yw: Å¼Ä…danie HTTP â†’ routing â†’ Controller â†’ View.
________________________________________
2. Aplikacja UI bez MVVM (MAUI lub WPF)
1.	UtwÃ³rz projekt:
o	MAUI: dotnet new maui -n DemoMaui
o	WPF: dotnet new wpf -n DemoWpf
2.	W gÅ‚Ã³wnym oknie / stronie dodaj elementy:
o	Pole tekstowe ImiÄ™, pole tekstowe Nazwisko, etykietÄ™ (Label/TextBlock), przycisk PoÅ‚Ä…cz.
3.	W code-behind obsÅ‚uÅ¼ zdarzenia:
o	TextChanged dla pÃ³l tekstowych â†’ zapisz dane do zmiennych.
o	Click dla przycisku â†’ ustaw w etykiecie wartoÅ›Ä‡ ImiÄ™ + Nazwisko.
4.	Zanotuj problemy: logika umieszczona w UI, brak testÃ³w, trudna rozbudowa (np. walidacja, komunikacja z API).
________________________________________
3. Refaktoryzacja do MVVM (Toolkit)
â€¢	Dodaj pakiet:
dotnet add package CommunityToolkit.Mvvm
â€¢	UtwÃ³rz klasÄ™ MainViewModel dziedziczÄ…cÄ… po ObservableObject.
â€¢	Dodaj pola [ObservableProperty] string FirstName, [ObservableProperty] string LastName.
â€¢	Dodaj wÅ‚aÅ›ciwoÅ›Ä‡ FullName => $"{FirstName} {LastName}".
â€¢	Zaimplementuj [RelayCommand] SaveAsync() (symulacja np. zapisu, await Task.Delay).
â€¢	PowiÄ…Å¼ ViewModel z UI:
o	MAUI â€“ w konstruktorze strony: BindingContext = new MainViewModel();
o	WPF â€“ DataContext = new MainViewModel(); w MainWindow.xaml.cs.
â€¢	ZamieÅ„ kontrolki w XAML na bindingi:
o	Entry/TextBox â†’ {Binding FirstName, Mode=TwoWay}
o	Button â†’ {Binding SaveCommand}
o	Label â†’ {Binding FullName}
________________________________________
4. Dodanie IsNotBusy / CanExecute
1.	W ViewModel dodaj:
2.	public bool IsNotBusy => !IsBusy;
3.	W atrybucie RelayCommand ustaw:
4.	[RelayCommand(CanExecute = nameof(IsNotBusy))]
5.	Uruchom aplikacjÄ™ i sprawdÅº: przycisk powinien byÄ‡ nieaktywny, kiedy IsBusy == true.
________________________________________
5. Walidacja
1.	Dodaj do ViewModelu logikÄ™:
o	JeÅ›li string.IsNullOrWhiteSpace(FirstName) â†’ ustaw wÅ‚aÅ›ciwoÅ›Ä‡ ValidationMessage = "ImiÄ™ jest wymagane".
2.	W XAML dodaj Label powiÄ…zany z ValidationMessage.
3.	Przetestuj: pozostaw pole puste i kliknij â€Zapiszâ€ â†’ powinien pojawiÄ‡ siÄ™ komunikat.
________________________________________
6. ValueConverter
â€¢	UtwÃ³rz konwerter, np. BoolInverseConverter.
â€¢	Zarejestruj go w ResourceDictionary.
â€¢	UÅ¼yj w XAML, np. do wÅ‚Ä…czania/wyÅ‚Ä…czania przycisku:
â€¢	<Button Text="Zapisz" 
â€¢	        Command="{Binding SaveCommand}" 
â€¢	        IsEnabled="{Binding IsBusy, Converter={StaticResource BoolInverseConverter}}"/>
â€¢	SprawdÅº â€“ przycisk staje siÄ™ nieaktywny podczas wykonywania operacji.
________________________________________
7. Dependency Injection
1.	W MAUI â€“ w MauiProgram.cs:
2.	builder.Services.AddSingleton<MainViewModel>();
3.	builder.Services.AddTransient<MainPage>();
4.	W MainPage.xaml.cs:
5.	public MainPage(MainViewModel vm)
6.	{
7.	    InitializeComponent();
8.	    BindingContext = vm;
9.	}
10.	W WPF skonfiguruj kontener (np. Microsoft.Extensions.DependencyInjection) w App.xaml.cs i rejestruj ViewModel/okna.
________________________________________
8. Testy jednostkowe ViewModelu
1.	UtwÃ³rz projekt testowy:
2.	dotnet new nunit -n DemoTests
3.	dotnet add DemoTests/DemoTests.csproj reference DemoMaui/DemoMaui.csproj
4.	Napisz test:
5.	[Test]
6.	public void FullName_Updates_OnFirstOrLastChange()
7.	{
8.	    var vm = new MainViewModel();
9.	    vm.FirstName = "Anna";
10.	    vm.LastName = "Nowak";
11.	    Assert.That(vm.FullName, Is.EqualTo("Anna Nowak"));
12.	}
13.	Uruchom testy i upewnij siÄ™, Å¼e logika dziaÅ‚a niezaleÅ¼nie od UI.
________________________________________
9. Nawigacja
â€¢	Dodaj nowÄ… stronÄ™ / okno DetailsPage.
â€¢	MAUI Shell:
â€¢	  
â€¢	await Shell.Current.GoToAsync("details", 
â€¢	    new Dictionary<string,object>{{"Item", SelectedContact}});
â€¢	  
â€¢	WPF:
â€¢	NavigationService.Navigate(new DetailsPage(contact));
â€¢	PrzekaÅ¼ obiekt do drugiej strony i wyÅ›wietl dane (np. peÅ‚ne imiÄ™ i nazwisko).
________________________________________
10. Stylizacja i zasoby
1.	W Resources/Styles.xaml zdefiniuj wÅ‚asne style:
o	Kolor gÅ‚Ã³wny aplikacji.
o	Styl globalny dla przyciskÃ³w (marginesy, font-size).
2.	UÅ¼yj AppThemeBinding, aby zmieniÄ‡ kolor tÅ‚a w trybie jasnym/ciemnym.
3.	Dodaj wÅ‚asny font (TTF/OTF) i uÅ¼yj w etykiecie.
4.	Dodaj ikonÄ™ (SVG) i ustaw jako Image.
________________________________________
11. Lifecycle (MAUI vs WPF)
1.	W MAUI:
o	ObsÅ‚uÅ¼ OnStart, OnSleep (lub OnAppStateChanged), OnResume.
o	Dodaj log do konsoli (np. â€aplikacja w tleâ€, â€aplikacja wznowionaâ€).
o	Zrozum â€“ aplikacja moÅ¼e zostaÄ‡ uÅ›piona przez system.
2.	W WPF:
o	SprawdÅº zdarzenia Startup, Exit.
o	Zrozum rÃ³Å¼nicÄ™ â€“ aplikacja desktopowa dziaÅ‚a dopÃ³ki uÅ¼ytkownik jej nie zamknie.
________________________________________
â† PowrÃ³t do planu zajÄ™Ä‡
ğŸ’»ğŸ’¼ğŸ“§
Â© 2025 Tomasz LeÅ› | Warsaw University of Technology

â€¢	Home
â€¢	Research
â€¢	Teaching
â€¢	Contact
Tworzenie aplikacji Blazor (.NET 8)
MateriaÅ‚y
Filmy (omawiane w zajÄ™ciach):
â€¢	Blazor SSR vs Server vs WebAssembly vs Auto â€“ https://www.youtube.com/watch?v=LHHBFh1rsGE
â€¢	CRUD z wszystkimi trybami renderowania (.NET 8) â€“ https://www.youtube.com/watch?v=w8imy7LT9zY
â€¢	CRUD z trybem WebAssembly (.NET 8) â€“ https://www.youtube.com/watch?v=AKiGGtBj1go
Dokumentacja:
â€¢	Blazor (ASP.NET Core) â€“ https://learn.microsoft.com/aspnet/core/blazor
â€¢	Render modes (.NET 8) â€“ https://learn.microsoft.com/aspnet/core/blazor/components/render-modes
â€¢	Komponenty / routing â€“ https://learn.microsoft.com/aspnet/core/blazor/fundamentals/routing
â€¢	Forms & EditForm â€“ https://learn.microsoft.com/aspnet/core/blazor/forms
â€¢	Stream rendering / enhanced navigation â€“ https://learn.microsoft.com/aspnet/core/blazor/components/rendering
â€¢	SignalR (Blazor Server) â€“ https://learn.microsoft.com/aspnet/core/signalr
â€¢	EF Core â€“ https://learn.microsoft.com/ef/core
â€¢	Hosting / publikacja â€“ https://learn.microsoft.com/aspnet/core/blazor/host-and-deploy
â€¢	PWA (Blazor WebAssembly) â€“ https://learn.microsoft.com/aspnet/core/blazor/progressive-web-app
Repozytoria:
â€¢	PrzykÅ‚ady oficjalne â€“ https://github.com/dotnet/aspnetcore/tree/main/src/Components
â€¢	Dotnet runtime & issues â€“ https://github.com/dotnet/aspnetcore/issues
________________________________________
Tematy do poruszenia
1.	Dlaczego Blazor (.NET 8 â€Blazor Web Appâ€)
o	Jeden szablon = wiele trybÃ³w renderowania (progressive enhancement).
o	SEO + szybkoÅ›Ä‡ pierwszego Å‚adowania (SSR).
o	MoÅ¼liwoÅ›Ä‡ przejÅ›cia do interaktywnoÅ›ci bez przepisywania caÅ‚oÅ›ci.
o	WspÃ³lny kod .NET (Model, walidacja, logika) â€“ brak duplikacji w JS/TS.
2.	Tryby renderowania (@rendermode)
o	Static SSR (brak interaktywnoÅ›ci) â€“ none.
o	Interactive Server â€“ logika po stronie serwera (SignalR/WebSocket), niski transfer, ograniczona skalowalnoÅ›Ä‡ (liczba poÅ‚Ä…czeÅ„).
o	Interactive WebAssembly â€“ logika w przeglÄ…darce, offline, wiÄ™kszy initial payload.
o	Interactive Auto â€“ pierwszy raz Server (szybki TTFB) potem przeÅ‚Ä…cza siÄ™ na WebAssembly (cache).
o	WybÃ³r per komponent / per strona / globalnie.
3.	Koszt / trade-off
o	Server: + maÅ‚y rozmiar startowy, - poÅ‚Ä…czenia staÅ‚e, latency roundtrip.
o	WebAssembly: + skalowalnoÅ›Ä‡, offline, PWA, - wiÄ™kszy poczÄ…tkowy download, cold start.
o	Auto: + UX, - wiÄ™ksza zÅ‚oÅ¼onoÅ›Ä‡ i debug.
o	SSR static: + minimalny koszt, idealne dla content / blog / landing.
4.	Stream Rendering & Enhanced Navigation
o	Szkielet strony natychmiast + pÃ³Åºniejszy dopÅ‚yw danych.
o	Eliminacja â€biaÅ‚ej stronyâ€ przy wolniejszych zapytaniach.
o	PorÃ³wnanie z klasycznym peÅ‚nym odÅ›wieÅ¼eniem.
5.	Struktura projektu â€Blazor Web Appâ€
o	Server (host + API + SSR).
o	Client (WebAssembly â€“ komponenty interaktywne).
o	Shared (modele / kontrakty / DTO / serwisy interfejsowe).
o	Rejestracja assembly klienta w Program.cs (dodanie interaktywnych komponentÃ³w).
o	RÃ³Å¼nice wzglÄ™dem dawnych szablonÃ³w â€Hosted WASMâ€.
6.	Formularze
o	EditForm (interaktywny) vs klasyczny POST w SSR static.
o	formname + [SupplyParameterFromForm] aby zadziaÅ‚aÅ‚o bez WebSocket / WASM.
o	Walidacja (DataAnnotations, komunikaty bÅ‚Ä™dÃ³w).
7.	Architektura
o	Warstwy: Controller / Service / Repository / DbContext / Shared models.
o	Interfejsy + implementacje (np. IGameService â€“ ServerGameService + ClientApiGameService).
o	Minimalizacja duplikacji kodu przy obu trybach.
8.	EF Core w Blazor
o	AddDbContext, migracje: dotnet ef migrations add, dotnet ef database update.
o	Seeding w OnModelCreating.
o	Konfiguracja connection string.
9.	PWA / Offline * Tylko WebAssembly (Service Worker, cache zasobÃ³w).
o	Zachowanie formularza w offline + LocalStorage / IndexedDB.
10.	Kiedy ktÃ³ry tryb? (skrÃ³t)
o	Tylko SSR static: content / marketing / SEO / minimalny koszt.
o	Server: maÅ‚y zespÃ³Å‚ backoffice (<50 aktywnych), szybka iteracja.
o	WebAssembly: duÅ¼a liczba interaktywnych uÅ¼ytkownikÃ³w, offline, PWA.
o	Auto: first paint krytyczny + pÃ³Åºniej intensywna interakcja.
________________________________________
Ä†wiczenia
1. Szablon SSR static
1.	dotnet new blazor -n BlogSsr --interactivity None
2.	Uruchom, dodaj stronÄ™ Blog.razor z listÄ… statycznych postÃ³w.
3.	Zmierz czas pierwszego Å‚adowania (DevTools).
2. Stream rendering
1.	W Blog.razor dodaj sztuczny delay (Task.Delay 1500ms).
2.	WÅ‚Ä…cz stream rendering â€“ pokaÅ¼ placeholder â€Åadowanieâ€¦â€.
3.	PorÃ³wnaj UX vs bez stream.
3. Dodanie interaktywnoÅ›ci (Server)
1.	UtwÃ³rz stronÄ™ Counter.razor (Server): @rendermode InteractiveServer.
2.	Obserwuj WebSocket w DevTools (Network â†’ WS).
3.	UsuÅ„ @rendermode â†’ brak inkrementacji.
4. Formularz bez interaktywnoÅ›ci
1.	Strona Contact.razor w SSR static z <form method="post">.
2.	Dodaj [SupplyParameterFromForm] + formname.
3.	WyÅ›wietl dane po POST (redirect / ten sam komponent).
5. Migracja do interaktywnego formularza
1.	ZamieÅ„ na EditForm.
2.	Dodaj DataAnnotations i walidacjÄ™.
6. Dodanie Client (WebAssembly)
1.	UtwÃ³rz nowy projekt Blazor Web App z WebAssembly.
2.	PrzenieÅ› komponent Counter do Client/Pages.
3.	Dodaj @rendermode InteractiveWebAssembly.
4.	PorÃ³wnaj payload (zakÅ‚adka Network > Wasm).
7. Model domenowy + EF Core
1.	Dodaj projekt Shared.
2.	Klasa VideoGame { Id, Title, Publisher, ReleaseYear }.
3.	DbContext + migracja + seeding 3 rekordy.
8. Warstwa usÅ‚ug
1.	IGameService + GameService (Server â€“ bezpoÅ›rednio DbContext).
2.	Rejestracja AddScoped.
3.	UtwÃ³rz API GameController (CRUD).
9. Druga implementacja (HTTP)
1.	ClientGameService uÅ¼ywa HttpClient.
2.	Wstrzyknij przez DI (warunkowo dla WASM).
3.	Ten sam interfejs â€“ brak zmian w komponencie listy.
10. Komponenty CRUD
1.	Games.razor (lista) â€“ SSR + stream.
2.	Przyciski: Dodaj (interaktywny przycisk), Edytuj, UsuÅ„.
3.	EditGame.razor (create/update) z podwÃ³jnÄ… trasÄ…:
o	@page "/games/edit"
o	@page "/games/edit/{id:int}"
11. Pre-rendering
1.	WÅ‚Ä…cz @rendermode bez parametrÃ³w â€“ zaobserwuj podwÃ³jne logi init.
2.	WyÅ‚Ä…cz: @rendermode new InteractiveServerRenderMode(prerender:false).
3.	Zanotuj rÃ³Å¼nicÄ™.
12. Tryb Auto
1.	ZmieÅ„ EditGame.razor â†’ @rendermode InteractiveAuto.
2.	WyczyÅ›Ä‡ cache, zaÅ‚aduj Ã—2 i obserwuj: pierwszy WebSocket, drugi â€“ brak.
13. Offline & PWA (WASM)
1.	WÅ‚Ä…cz PWA (Service Worker) â€“ aktualizacja projektu.
2.	OdÅ‚Ä…cz sieÄ‡ â†’ test odczytu listy z cache / LocalStorage fallback.
3.	Zainstaluj aplikacjÄ™ na puplicie.
________________________________________
â† PowrÃ³t do planu zajÄ™Ä‡
ğŸ’»ğŸ’¼ğŸ“§
Â© 2025 Tomasz LeÅ› | Warsaw University of Technology

â€¢	Home
â€¢	Research
â€¢	Teaching
â€¢	Contact
Tworzenie aplikacji rozproszonych
MateriaÅ‚y
Wideo:
â€¢	Build Better Apps with .NET Aspire â€“ https://www.youtube.com/watch?v=e36NEWqO7GQ
â€¢	What is .NET Aspire? â€“ https://www.youtube.com/watch?v=fN3ufsIF7vs
â€¢	Redis, PostgreSQL, Messaging & More with .NET Aspire â€“ https://www.youtube.com/watch?v=4t_-g4fwEG0
Dokumentacja:
â€¢	.NET Aspire â€“ https://learn.microsoft.com/dotnet/aspire
â€¢	Service discovery â€“ https://learn.microsoft.com/dotnet/aspire/fundamentals/service-discovery
â€¢	Health checks (ASP.NET Core) â€“ https://learn.microsoft.com/aspnet/core/host-and-deploy/health-checks
â€¢	OpenTelemetry (.NET) â€“ https://learn.microsoft.com/dotnet/core/diagnostics/observability
â€¢	EF Core â€“ https://learn.microsoft.com/ef/core
â€¢	Azure Developer CLI (azd) â€“ https://learn.microsoft.com/azure/developer/azure-developer-cli/
â€¢	Aspire Dashboard (standalone) â€“ https://aspiredashboard.com
â€¢	Projekt aspirate (Kubernetes) â€“ https://github.com/batect/aspirate
Repozytoria przykÅ‚adowe:
â€¢	Aspire samples â€“ https://github.com/dotnet/aspire-samples
â€¢	eShop + Aspire (przykÅ‚ad zÅ‚oÅ¼ony) â€“ https://github.com/dotnet/eShop
â€¢	Community components (NuGet search tag: Aspire)
________________________________________
Dlaczego .NET Aspire?
Problemy typowe przy wielu usÅ‚ugach:
â€¢	Wielokrotne uruchamianie projektÃ³w rÄ™cznie / konfiguracje debug.
â€¢	RÃ³Å¼ne porty / zmienne Å›rodowiskowe (spÃ³jnoÅ›Ä‡ u developerÃ³w).
â€¢	Brak spÃ³jnej obserwowalnoÅ›ci (logi, metryki, Å›lady).
â€¢	SkÅ‚adanie connection stringÃ³w rÄ™cznie.
â€¢	RÄ™czne odpalanie baz / cache / brokerÃ³w wiadomoÅ›ci (Docker).
â€¢	Rozjazd config: DEV â‰  PROD.
Aspire zapewnia:
â€¢	Orchestrator (AppHost) â€“ deklaratywny opis zasobÃ³w.
â€¢	Service Discovery â€“ identyfikatory zamiast twardych URL.
â€¢	Smart defaults: OpenTelemetry (logs/traces/metrics), health checks, resiliency (Polly).
â€¢	Dashboard deweloperski (podglÄ…d w czasie rzeczywistym).
â€¢	Integracje (Redis, PostgreSQL, Service Bus, Storage, Messaging, AI).
â€¢	Manifest â†’ narzÄ™dzia (azd, aspirate) â†’ wdroÅ¼enie (Azure Container Apps / Kubernetes).
â€¢	ElastycznoÅ›Ä‡ â€“ moÅ¼esz uÅ¼yÄ‡ tylko czÄ™Å›ci (np. sam dashboard + OTel).
________________________________________
Kluczowe pojÄ™cia
PojÄ™cie	Opis
AppHost (Distributed App)	Projekt â€sklejajÄ…cyâ€ â€“ definiuje zasoby i relacje.
Service Defaults	WspÃ³lne rozszerzenia: telemetry, health, resilience, discovery.
Component / Hosting package	NuGet â€Aspire.*â€ dla integracji (baza, cache, messaging).
Service Discovery	Wzorzec: https+http://products zamiast https://localhost:5003.
Resilience	DomyÅ›lnie retry / timeout / circuit breaker (konfigurowalne).
Dashboard	UI (Blazor + Fluent) â€“ logi, traces, metrics, health.
Manifest	JSON generowany przez AppHost â€“ wejÅ›cie do narzÄ™dzi wdroÅ¼eniowych.
Standalone Dashboard	Kontener do lokalnej obserwowalnoÅ›ci istniejÄ…cych aplikacji.
________________________________________
Tematy do poruszenia
1.	Czym jest architektura rozproszona (usÅ‚ugi, granice, kontrakty).
2.	Evolucja: monolit â†’ modularny â†’ usÅ‚ugi / â€wyspyâ€ funkcjonalne.
3.	.NET Aspire â€“ zakres vs peÅ‚ny orchestrator (nie zastÄ™puje K8s).
4.	AppHost i deklaratywne zasoby (projekty, kontenery, connection strings).
5.	Service Discovery (schematy https, fallback do http, identyfikatory).
6.	Telemetria:
o	Logs (ustrukturyzowane),
o	Distributed Traces,
o	Metrics (HTTP, GC, wÅ‚asne).
7.	Health & Liveness:
o	/health (zaleÅ¼noÅ›ci),
o	/alive (samo-Å¼ycie procesu).
8.	Resilience (Polly) â€“ retry z jitterem, timeouts, circuit breaker.
9.	Komponenty:
o	Redis (cache / output cache / distributed cache),
o	PostgreSQL (EF Core),
o	Messaging (Service Bus / RabbitMQ),
o	Storage / AI / Key Vault (wzorzec rozszerzania).
10.	Dashboard â€“ analiza â€hot pathâ€, wykrywanie bÅ‚Ä™dÃ³w.
11.	Wersjonowanie schematu i manifestu.
12.	Deployment opcje:
o	â€Klasycznieâ€ (publish pojedynczych projektÃ³w),
o	Manifest + azd (Azure Container Apps),
o	Manifest + aspirate (Kubernetes),
o	CI/CD (GitHub Actions / Azure DevOps).
13.	BezpieczeÅ„stwo:
o	ZarzÄ…dzane toÅ¼samoÅ›ci / sekrety poza repo,
o	Ograniczanie endpointÃ³w (external vs internal).
14.	Zamiana lokalnych endpointÃ³w â†’ discovery (migration path).
15.	Standalone Dashboard dla istniejÄ…cych mikroserwisÃ³w.
16.	Optymalizacja kosztÃ³w (skalowanie do zera, granularne usÅ‚ugi).
17.	Scenariusze architektoniczne (maÅ‚y zespÃ³Å‚ / wzrost / enterprise).
________________________________________
PrzykÅ‚adowe komponenty i rola
Komponent	Zastosowanie	WartoÅ›Ä‡ w Aspire
Redis	Cache / Output cache	Automatyczna konfiguracja + health + telemetry
PostgreSQL	TrwaÅ‚a baza danych	Connection string przez discovery
Service Bus / RabbitMQ	Asynchroniczne komunikaty	Traces korelacyjne
Key Vault / Secrets	Sekrety produkcyjne	Oddzielenie config od kodu
OpenAI / AI klient	Enrichment / rekomendacje	ObserwowalnoÅ›Ä‡ wywoÅ‚aÅ„
Dashboard	Diagnoza lokalna	Szybsze debugowanie
________________________________________
Ä†wiczenia
1. Inicjalizacja projektu Aspire
1.	dotnet new aspire -n ShopPlatform (lub dotnet new aspire-starter).
2.	Uruchom AppHost â€“ sprawdÅº Dashboard.
3.	Przeanalizuj wygenerowane ServiceDefaults.
2. Dodanie istniejÄ…cego API i frontendu
1.	Do AppHost dodaj: builder.AddProject("Api","../Shop.Api/Shop.Api.csproj").
2.	Dodaj Blazor (lub MVC) frontend.
3.	OtwÃ³rz Dashboard â†’ Resources (powinny byÄ‡ 2 projekty).
3. Service discovery
1.	W API nazwij projekt w AppHost: "products".
2.	W kliencie zamieÅ„ https://localhost:xxxxx na: https+http://products.
3.	UsuÅ„ twarde porty z appsettings.json.
4. Redis jako cache
1.	var cache = builder.AddRedis("cache");
2.	Frontend: builder.AddRedisOutputCache("cache");
3.	Oznacz endpoint lub komponent: [OutputCache(Duration = 5)].
4.	Obserwuj w Dashboard: traces (cache hit / miss).
5. Migracja SQLite â†’ PostgreSQL
1.	AppHost: var db = builder.AddPostgres("postgres");
2.	var productsDb = db.AddDatabase("productsdb"); + reference do API.
3.	API: builder.AddNpgsqlDbContext<ProductsContext>("productsdb");
4.	dotnet ef migrations add Init && dotnet ef database update.
5.	SprawdÅº PGAdmin (opcjonalnie WithPgAdmin()).
6. Health / Alive
1.	Odpal /health i /alive.
2.	Zatrzymaj kontener Redis (docker stop ...).
3.	/alive = Healthy, /health = Unhealthy (dependency fail).
7. Resilience (retry)
1.	W API dodaj losowy if(Random.Shared.Next(0,4)==0) throw ....
2.	W kliencie wywoÅ‚aj seriÄ™ zapytaÅ„.
3.	W traces zobacz retry (Polly) â€“ czasy odstÄ™pÃ³w.
8. Dostosowanie polityk
1.	ServiceDefaults: builder.Services.AddStandardResilienceHandler().Configure(o => o.Retry.MaxRetryAttempts = 2);
2.	PorÃ³wnaj zachowanie (mniej prÃ³b).
9. WdroÅ¼enie z Azure Developer CLI
1.	azd init (wewnÄ…trz AppHost).
2.	azd up â†’ wybierz subskrypcjÄ™ + region.
3.	OtwÃ³rz zdalny Dashboard (Managed Identity).
4.	Zweryfikuj environment variables (sekcja details).
10. Wariant Kubernetes (opcjonalnie)
1.	Zainstaluj aspirate.
2.	aspirate generate --manifest manifest.json --output k8s.
3.	Przejrzyj wygenerowane YAML.
________________________________________
Strategia migracji istniejÄ…cej aplikacji
Etap	Cel	DziaÅ‚ania
1	ObserwowalnoÅ›Ä‡	Dodaj ServiceDefaults + OpenTelemetry
2	Discovery	ZamieÅ„ twarde URL na identyfikatory
3	Komponenty	Redis / Postgres / Message Bus
4	Resilience	Dostosuj polityki retry / timeout
5	Deployment	Manifest + azd / aspirate
6	Optymalizacja	Profiling traces + redukcja cold paths
________________________________________
Pytania kontrolne
1.	RÃ³Å¼nica /health vs /alive?
2.	Co daje service discovery vs twarde URL?
3.	Jak dodaÄ‡ nowÄ… bazÄ™ w AppHost i uÅ¼yÄ‡ w EF Core?
4.	Gdzie zmieniÄ‡ retry attempts?
5.	Jak wystawiÄ‡ tylko frontend publicznie?
6.	Jak uruchomiÄ‡ Dashboard standalone?
7.	Co zawiera manifest i kto go konsumuje?
8.	Kiedy NIE uÅ¼ywaÄ‡ mikroserwisÃ³w?
________________________________________
â† PowrÃ³t do planu zajÄ™Ä‡
ğŸ’»ğŸ’¼ğŸ“§
Â© 2025 Tomasz LeÅ› | Warsaw University of Technology

