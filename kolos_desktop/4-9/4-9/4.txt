
Home
Research
Teaching
Contact
Tworzenie aplikacji Blazor (.NET 8)
MateriaÅ‚y
Filmy (omawiane w zajÄ™ciach):

Blazor SSR vs Server vs WebAssembly vs Auto â€“ https://www.youtube.com/watch?v=LHHBFh1rsGE
CRUD z wszystkimi trybami renderowania (.NET 8) â€“ https://www.youtube.com/watch?v=w8imy7LT9zY
CRUD z trybem WebAssembly (.NET 8) â€“ https://www.youtube.com/watch?v=AKiGGtBj1go
Dokumentacja:

Blazor (ASP.NET Core) â€“ https://learn.microsoft.com/aspnet/core/blazor
Render modes (.NET 8) â€“ https://learn.microsoft.com/aspnet/core/blazor/components/render-modes
Komponenty / routing â€“ https://learn.microsoft.com/aspnet/core/blazor/fundamentals/routing
Forms & EditForm â€“ https://learn.microsoft.com/aspnet/core/blazor/forms
Stream rendering / enhanced navigation â€“ https://learn.microsoft.com/aspnet/core/blazor/components/rendering
SignalR (Blazor Server) â€“ https://learn.microsoft.com/aspnet/core/signalr
EF Core â€“ https://learn.microsoft.com/ef/core
Hosting / publikacja â€“ https://learn.microsoft.com/aspnet/core/blazor/host-and-deploy
PWA (Blazor WebAssembly) â€“ https://learn.microsoft.com/aspnet/core/blazor/progressive-web-app
Repozytoria:

PrzykÅ‚ady oficjalne â€“ https://github.com/dotnet/aspnetcore/tree/main/src/Components
Dotnet runtime & issues â€“ https://github.com/dotnet/aspnetcore/issues
Tematy do poruszenia
Dlaczego Blazor (.NET 8 â€Blazor Web Appâ€)
Jeden szablon = wiele trybÃ³w renderowania (progressive enhancement).
SEO + szybkoÅ›Ä‡ pierwszego Å‚adowania (SSR).
MoÅ¼liwoÅ›Ä‡ przejÅ›cia do interaktywnoÅ›ci bez przepisywania caÅ‚oÅ›ci.
WspÃ³lny kod .NET (Model, walidacja, logika) â€“ brak duplikacji w JS/TS.
Tryby renderowania (@rendermode)
Static SSR (brak interaktywnoÅ›ci) â€“ none.
Interactive Server â€“ logika po stronie serwera (SignalR/WebSocket), niski transfer, ograniczona skalowalnoÅ›Ä‡ (liczba poÅ‚Ä…czeÅ„).
Interactive WebAssembly â€“ logika w przeglÄ…darce, offline, wiÄ™kszy initial payload.
Interactive Auto â€“ pierwszy raz Server (szybki TTFB) potem przeÅ‚Ä…cza siÄ™ na WebAssembly (cache).
WybÃ³r per komponent / per strona / globalnie.
Koszt / trade-off
Server: + maÅ‚y rozmiar startowy, - poÅ‚Ä…czenia staÅ‚e, latency roundtrip.
WebAssembly: + skalowalnoÅ›Ä‡, offline, PWA, - wiÄ™kszy poczÄ…tkowy download, cold start.
Auto: + UX, - wiÄ™ksza zÅ‚oÅ¼onoÅ›Ä‡ i debug.
SSR static: + minimalny koszt, idealne dla content / blog / landing.
Stream Rendering & Enhanced Navigation
Szkielet strony natychmiast + pÃ³Åºniejszy dopÅ‚yw danych.
Eliminacja â€biaÅ‚ej stronyâ€ przy wolniejszych zapytaniach.
PorÃ³wnanie z klasycznym peÅ‚nym odÅ›wieÅ¼eniem.
Struktura projektu â€Blazor Web Appâ€
Server (host + API + SSR).
Client (WebAssembly â€“ komponenty interaktywne).
Shared (modele / kontrakty / DTO / serwisy interfejsowe).
Rejestracja assembly klienta w Program.cs (dodanie interaktywnych komponentÃ³w).
RÃ³Å¼nice wzglÄ™dem dawnych szablonÃ³w â€Hosted WASMâ€.
Formularze
EditForm (interaktywny) vs klasyczny POST w SSR static.
formname + [SupplyParameterFromForm] aby zadziaÅ‚aÅ‚o bez WebSocket / WASM.
Walidacja (DataAnnotations, komunikaty bÅ‚Ä™dÃ³w).
Architektura
Warstwy: Controller / Service / Repository / DbContext / Shared models.
Interfejsy + implementacje (np. IGameService â€“ ServerGameService + ClientApiGameService).
Minimalizacja duplikacji kodu przy obu trybach.
EF Core w Blazor
AddDbContext, migracje: dotnet ef migrations add, dotnet ef database update.
Seeding w OnModelCreating.
Konfiguracja connection string.
PWA / Offline * Tylko WebAssembly (Service Worker, cache zasobÃ³w).
Zachowanie formularza w offline + LocalStorage / IndexedDB.
Kiedy ktÃ³ry tryb? (skrÃ³t)
Tylko SSR static: content / marketing / SEO / minimalny koszt.
Server: maÅ‚y zespÃ³Å‚ backoffice (<50 aktywnych), szybka iteracja.
WebAssembly: duÅ¼a liczba interaktywnych uÅ¼ytkownikÃ³w, offline, PWA.
Auto: first paint krytyczny + pÃ³Åºniej intensywna interakcja.
Ä†wiczenia
1. Szablon SSR static
dotnet new blazor -n BlogSsr --interactivity None
Uruchom, dodaj stronÄ™ Blog.razor z listÄ… statycznych postÃ³w.
Zmierz czas pierwszego Å‚adowania (DevTools).
2. Stream rendering
W Blog.razor dodaj sztuczny delay (Task.Delay 1500ms).
WÅ‚Ä…cz stream rendering â€“ pokaÅ¼ placeholder â€Åadowanieâ€¦â€.
PorÃ³wnaj UX vs bez stream.
3. Dodanie interaktywnoÅ›ci (Server)
UtwÃ³rz stronÄ™ Counter.razor (Server): @rendermode InteractiveServer.
Obserwuj WebSocket w DevTools (Network â†’ WS).
UsuÅ„ @rendermode â†’ brak inkrementacji.
4. Formularz bez interaktywnoÅ›ci
Strona Contact.razor w SSR static z <form method="post">.
Dodaj [SupplyParameterFromForm] + formname.
WyÅ›wietl dane po POST (redirect / ten sam komponent).
5. Migracja do interaktywnego formularza
ZamieÅ„ na EditForm.
Dodaj DataAnnotations i walidacjÄ™.
6. Dodanie Client (WebAssembly)
UtwÃ³rz nowy projekt Blazor Web App z WebAssembly.
PrzenieÅ› komponent Counter do Client/Pages.
Dodaj @rendermode InteractiveWebAssembly.
PorÃ³wnaj payload (zakÅ‚adka Network > Wasm).
7. Model domenowy + EF Core
Dodaj projekt Shared.
Klasa VideoGame { Id, Title, Publisher, ReleaseYear }.
DbContext + migracja + seeding 3 rekordy.
8. Warstwa usÅ‚ug
IGameService + GameService (Server â€“ bezpoÅ›rednio DbContext).
Rejestracja AddScoped.
UtwÃ³rz API GameController (CRUD).
9. Druga implementacja (HTTP)
ClientGameService uÅ¼ywa HttpClient.
Wstrzyknij przez DI (warunkowo dla WASM).
Ten sam interfejs â€“ brak zmian w komponencie listy.
10. Komponenty CRUD
Games.razor (lista) â€“ SSR + stream.
Przyciski: Dodaj (interaktywny przycisk), Edytuj, UsuÅ„.
EditGame.razor (create/update) z podwÃ³jnÄ… trasÄ…:
@page "/games/edit"
@page "/games/edit/{id:int}"
11. Pre-rendering
WÅ‚Ä…cz @rendermode bez parametrÃ³w â€“ zaobserwuj podwÃ³jne logi init.
WyÅ‚Ä…cz: @rendermode new InteractiveServerRenderMode(prerender:false).
Zanotuj rÃ³Å¼nicÄ™.
12. Tryb Auto
ZmieÅ„ EditGame.razor â†’ @rendermode InteractiveAuto.
WyczyÅ›Ä‡ cache, zaÅ‚aduj Ã—2 i obserwuj: pierwszy WebSocket, drugi â€“ brak.
13. Offline & PWA (WASM)
WÅ‚Ä…cz PWA (Service Worker) â€“ aktualizacja projektu.
OdÅ‚Ä…cz sieÄ‡ â†’ test odczytu listy z cache / LocalStorage fallback.
Zainstaluj aplikacjÄ™ na puplicie.
â† PowrÃ³t do planu zajÄ™Ä‡

ğŸ’»
ğŸ’¼
ğŸ“§
Â© 2025 Tomasz LeÅ› | Warsaw University of Technology