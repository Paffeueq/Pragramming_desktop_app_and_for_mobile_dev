
Home
Research
Teaching
Contact
Tworzenie aplikacji rozproszonych
MateriaÅ‚y
Wideo:

Build Better Apps with .NET Aspire â€“ https://www.youtube.com/watch?v=e36NEWqO7GQ
What is .NET Aspire? â€“ https://www.youtube.com/watch?v=fN3ufsIF7vs
Redis, PostgreSQL, Messaging & More with .NET Aspire â€“ https://www.youtube.com/watch?v=4t_-g4fwEG0
Dokumentacja:

.NET Aspire â€“ https://learn.microsoft.com/dotnet/aspire
Service discovery â€“ https://learn.microsoft.com/dotnet/aspire/fundamentals/service-discovery
Health checks (ASP.NET Core) â€“ https://learn.microsoft.com/aspnet/core/host-and-deploy/health-checks
OpenTelemetry (.NET) â€“ https://learn.microsoft.com/dotnet/core/diagnostics/observability
EF Core â€“ https://learn.microsoft.com/ef/core
Azure Developer CLI (azd) â€“ https://learn.microsoft.com/azure/developer/azure-developer-cli/
Aspire Dashboard (standalone) â€“ https://aspiredashboard.com
Projekt aspirate (Kubernetes) â€“ https://github.com/batect/aspirate
Repozytoria przykÅ‚adowe:

Aspire samples â€“ https://github.com/dotnet/aspire-samples
eShop + Aspire (przykÅ‚ad zÅ‚oÅ¼ony) â€“ https://github.com/dotnet/eShop
Community components (NuGet search tag: Aspire)
Dlaczego .NET Aspire?
Problemy typowe przy wielu usÅ‚ugach:

Wielokrotne uruchamianie projektÃ³w rÄ™cznie / konfiguracje debug.
RÃ³Å¼ne porty / zmienne Å›rodowiskowe (spÃ³jnoÅ›Ä‡ u developerÃ³w).
Brak spÃ³jnej obserwowalnoÅ›ci (logi, metryki, Å›lady).
SkÅ‚adanie connection stringÃ³w rÄ™cznie.
RÄ™czne odpalanie baz / cache / brokerÃ³w wiadomoÅ›ci (Docker).
Rozjazd config: DEV â‰  PROD.
Aspire zapewnia:

Orchestrator (AppHost) â€“ deklaratywny opis zasobÃ³w.
Service Discovery â€“ identyfikatory zamiast twardych URL.
Smart defaults: OpenTelemetry (logs/traces/metrics), health checks, resiliency (Polly).
Dashboard deweloperski (podglÄ…d w czasie rzeczywistym).
Integracje (Redis, PostgreSQL, Service Bus, Storage, Messaging, AI).
Manifest â†’ narzÄ™dzia (azd, aspirate) â†’ wdroÅ¼enie (Azure Container Apps / Kubernetes).
ElastycznoÅ›Ä‡ â€“ moÅ¼esz uÅ¼yÄ‡ tylko czÄ™Å›ci (np. sam dashboard + OTel).
Kluczowe pojÄ™cia
PojÄ™cie	Opis
AppHost (Distributed App)	Projekt â€sklejajÄ…cyâ€ â€“ definiuje zasoby i relacje.
Service Defaults	WspÃ³lne rozszerzenia: telemetry, health, resilience, discovery.
Component / Hosting package	NuGet â€Aspire.*â€ dla integracji (baza, cache, messaging).
Service Discovery	Wzorzec: https+http://products zamiast https://localhost:5003.
Resilience	DomyÅ›lnie retry / timeout / circuit breaker (konfigurowalne).
Dashboard	UI (Blazor + Fluent) â€“ logi, traces, metrics, health.
Manifest	JSON generowany przez AppHost â€“ wejÅ›cie do narzÄ™dzi wdroÅ¼eniowych.
Standalone Dashboard	Kontener do lokalnej obserwowalnoÅ›ci istniejÄ…cych aplikacji.
Tematy do poruszenia
Czym jest architektura rozproszona (usÅ‚ugi, granice, kontrakty).
Evolucja: monolit â†’ modularny â†’ usÅ‚ugi / â€wyspyâ€ funkcjonalne.
.NET Aspire â€“ zakres vs peÅ‚ny orchestrator (nie zastÄ™puje K8s).
AppHost i deklaratywne zasoby (projekty, kontenery, connection strings).
Service Discovery (schematy https, fallback do http, identyfikatory).
Telemetria:
Logs (ustrukturyzowane),
Distributed Traces,
Metrics (HTTP, GC, wÅ‚asne).
Health & Liveness:
/health (zaleÅ¼noÅ›ci),
/alive (samo-Å¼ycie procesu).
Resilience (Polly) â€“ retry z jitterem, timeouts, circuit breaker.
Komponenty:
Redis (cache / output cache / distributed cache),
PostgreSQL (EF Core),
Messaging (Service Bus / RabbitMQ),
Storage / AI / Key Vault (wzorzec rozszerzania).
Dashboard â€“ analiza â€hot pathâ€, wykrywanie bÅ‚Ä™dÃ³w.
Wersjonowanie schematu i manifestu.
Deployment opcje:
â€Klasycznieâ€ (publish pojedynczych projektÃ³w),
Manifest + azd (Azure Container Apps),
Manifest + aspirate (Kubernetes),
CI/CD (GitHub Actions / Azure DevOps).
BezpieczeÅ„stwo:
ZarzÄ…dzane toÅ¼samoÅ›ci / sekrety poza repo,
Ograniczanie endpointÃ³w (external vs internal).
Zamiana lokalnych endpointÃ³w â†’ discovery (migration path).
Standalone Dashboard dla istniejÄ…cych mikroserwisÃ³w.
Optymalizacja kosztÃ³w (skalowanie do zera, granularne usÅ‚ugi).
Scenariusze architektoniczne (maÅ‚y zespÃ³Å‚ / wzrost / enterprise).
PrzykÅ‚adowe komponenty i rola
Komponent	Zastosowanie	WartoÅ›Ä‡ w Aspire
Redis	Cache / Output cache	Automatyczna konfiguracja + health + telemetry
PostgreSQL	TrwaÅ‚a baza danych	Connection string przez discovery
Service Bus / RabbitMQ	Asynchroniczne komunikaty	Traces korelacyjne
Key Vault / Secrets	Sekrety produkcyjne	Oddzielenie config od kodu
OpenAI / AI klient	Enrichment / rekomendacje	ObserwowalnoÅ›Ä‡ wywoÅ‚aÅ„
Dashboard	Diagnoza lokalna	Szybsze debugowanie
Ä†wiczenia
1. Inicjalizacja projektu Aspire
dotnet new aspire -n ShopPlatform (lub dotnet new aspire-starter).
Uruchom AppHost â€“ sprawdÅº Dashboard.
Przeanalizuj wygenerowane ServiceDefaults.
2. Dodanie istniejÄ…cego API i frontendu
Do AppHost dodaj: builder.AddProject("Api","../Shop.Api/Shop.Api.csproj").
Dodaj Blazor (lub MVC) frontend.
OtwÃ³rz Dashboard â†’ Resources (powinny byÄ‡ 2 projekty).
3. Service discovery
W API nazwij projekt w AppHost: "products".
W kliencie zamieÅ„ https://localhost:xxxxx na: https+http://products.
UsuÅ„ twarde porty z appsettings.json.
4. Redis jako cache
var cache = builder.AddRedis("cache");
Frontend: builder.AddRedisOutputCache("cache");
Oznacz endpoint lub komponent: [OutputCache(Duration = 5)].
Obserwuj w Dashboard: traces (cache hit / miss).
5. Migracja SQLite â†’ PostgreSQL
AppHost: var db = builder.AddPostgres("postgres");
var productsDb = db.AddDatabase("productsdb"); + reference do API.
API: builder.AddNpgsqlDbContext<ProductsContext>("productsdb");
dotnet ef migrations add Init && dotnet ef database update.
SprawdÅº PGAdmin (opcjonalnie WithPgAdmin()).
6. Health / Alive
Odpal /health i /alive.
Zatrzymaj kontener Redis (docker stop ...).
/alive = Healthy, /health = Unhealthy (dependency fail).
7. Resilience (retry)
W API dodaj losowy if(Random.Shared.Next(0,4)==0) throw ....
W kliencie wywoÅ‚aj seriÄ™ zapytaÅ„.
W traces zobacz retry (Polly) â€“ czasy odstÄ™pÃ³w.
8. Dostosowanie polityk
ServiceDefaults: builder.Services.AddStandardResilienceHandler().Configure(o => o.Retry.MaxRetryAttempts = 2);
PorÃ³wnaj zachowanie (mniej prÃ³b).
9. WdroÅ¼enie z Azure Developer CLI
azd init (wewnÄ…trz AppHost).
azd up â†’ wybierz subskrypcjÄ™ + region.
OtwÃ³rz zdalny Dashboard (Managed Identity).
Zweryfikuj environment variables (sekcja details).
10. Wariant Kubernetes (opcjonalnie)
Zainstaluj aspirate.
aspirate generate --manifest manifest.json --output k8s.
Przejrzyj wygenerowane YAML.
Strategia migracji istniejÄ…cej aplikacji
Etap	Cel	DziaÅ‚ania
1	ObserwowalnoÅ›Ä‡	Dodaj ServiceDefaults + OpenTelemetry
2	Discovery	ZamieÅ„ twarde URL na identyfikatory
3	Komponenty	Redis / Postgres / Message Bus
4	Resilience	Dostosuj polityki retry / timeout
5	Deployment	Manifest + azd / aspirate
6	Optymalizacja	Profiling traces + redukcja cold paths
Pytania kontrolne
RÃ³Å¼nica /health vs /alive?
Co daje service discovery vs twarde URL?
Jak dodaÄ‡ nowÄ… bazÄ™ w AppHost i uÅ¼yÄ‡ w EF Core?
Gdzie zmieniÄ‡ retry attempts?
Jak wystawiÄ‡ tylko frontend publicznie?
Jak uruchomiÄ‡ Dashboard standalone?
Co zawiera manifest i kto go konsumuje?
Kiedy NIE uÅ¼ywaÄ‡ mikroserwisÃ³w?
â† PowrÃ³t do planu zajÄ™Ä‡

ğŸ’»
ğŸ’¼
ğŸ“§
Â© 2025 Tomasz LeÅ› | Warsaw University of Technology